<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>EIF Leaderboard</title>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
<style>
  :root{
    --bg1: #ff8a00;
    --bg2: #ffd24d;
    --accent: #1e1e1e;
    --table-shadow: rgba(0,0,0,0.15);
    --update-glow: #e6ffec;
    --moving-color: #008000;
    --gold: #FFC72C;
    --silver: #A9B3B9;
    --bronze: #8B4513;
    --pod-bg: #ffffff;
  }
  html,body{height:100%;margin:0;}
  body{
    min-height:100%;
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:40px;
    font-family: "Poppins", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    color:white; 
    padding:30px 20px;
    background: linear-gradient(135deg, var(--bg1) 0%, var(--bg2) 60%);
    background-attachment: fixed;
  }
  h1{
    margin:0;
    margin-bottom: 25px;
    font-size: 4.5rem; 
    font-weight: 900; 
    letter-spacing:3px;
    text-transform:uppercase;
    display:flex;
    align-items:center;
    gap:12px;
    color: #fff; 
    text-shadow: 0 6px 12px rgba(0,0,0,0.5); 
    line-height: 1;
  }
  .podium-wrap{
    width:95%;
    max-width:1000px;
    display:flex;
    justify-content:center;
    align-items:flex-end;
    gap:18px;
    padding:10px;
    margin-bottom: 20px;
  }
  .podium{
    display:flex;
    gap:16px;
    align-items:flex-end;
    width:100%;
    justify-content:center;
    max-width:900px;
  }
  .pod{
    width: 180px;
    min-height: 120px;
    border-radius:16px;
    background: var(--pod-bg); 
    color: var(--accent);
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:flex-end;
    padding: 24px 16px 16px; 
    position:relative;
    transform-origin: bottom center;
    transition: transform 300ms ease;
    border: 3px solid transparent;
  }
  .pod.first{ transform: translateY(-16px) scale(1.05); } 
  .pod.second{ transform: translateY(0) scale(1.0); } 
  .pod.third{ transform: translateY(8px) scale(0.95); } 
  .pod .place{
    position: absolute;
    top: -20px; 
    left: 50%;
    transform: translateX(-50%);
    font-weight: 900; 
    font-size: 2.2rem; 
    line-height: 1.2;
    padding: 6px 14px;
    border-radius: 10px;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
    border: 3px solid;
    z-index: 20;
    text-align: center; 
  }
  .pod.first .place { background: var(--gold); color: #333; border-color: #fff; }
  .pod.second .place { background: var(--silver); color: #333; border-color: #fff; }
  .pod.third .place { background: var(--bronze); color: white; border-color: #fff; }
  .pod .name{
    font-weight: 800; 
    font-size: 1.1rem; 
    white-space: normal; 
    text-overflow: clip; 
    overflow: visible;
    width:100%;
    text-align:center;
    color: var(--accent);
    margin-top: 8px;
    line-height: 1.2;
  }
  .pod .points{
    font-size:1.1rem; 
    margin-top: 10px;
    padding: 0;
    background: transparent;
    font-weight: 600; 
    color: #444; 
  }
  .table-wrap{
    width: 95%;
    max-width: 1000px;
    background: transparent; 
    border-radius:14px;
    padding:0 10px 10px; 
    box-shadow: 0 15px 40px var(--table-shadow); 
    overflow-x: auto;
  }
  table{
    width:100%;
    border-collapse: separate; 
    border-spacing: 0 14px; 
    overflow: hidden;
    color:var(--accent); 
    table-layout: auto; 
    padding-top: 50px; 
  }
  thead{
    position: sticky;
    top: 0;
    z-index: 10;
    background: #fcfcfc; 
    border-radius: 14px 14px 0 0;
    box-shadow: 0 5px 10px rgba(0,0,0,0.1);
  }
  thead th{
    padding:15px 10px;
    text-transform:uppercase;
    font-size:0.85rem;
    letter-spacing:1.5px;
    text-align:center;
    background: linear-gradient(to bottom, #f5f5f5, #e0e0e0);
    border-bottom:3px solid var(--bg1);
    color: #444;
  }
  tbody tr{
    border-radius: 8px; 
    box-shadow: 0 4px 8px rgba(0,0,0,0.1); 
    background-color: white; 
    transition: transform 500ms cubic-bezier(.2,.8,.2,1), background-color 220ms ease, box-shadow 500ms ease;
    will-change: transform;
    position: relative; 
    font-weight: 500;
  }
  tbody td{
    padding:14px 10px;
    text-align:center;
    border-bottom: none; 
    font-size:1rem;
    vertical-align:middle;
    font-weight: 500;
  }
  tbody td:first-child { border-top-left-radius: 8px; border-bottom-left-radius: 8px; }
  tbody td:last-child { border-top-right-radius: 8px; border-bottom-right-radius: 8px; }
  tbody tr.updated-cell { background-color: var(--update-glow) !important; }
  tbody tr.moving {
    box-shadow: 0 12px 30px rgba(0, 150, 0, 0.4);
    background-color: #8cffb3 !important; 
    color: var(--moving-color);
    font-weight: 700; 
    z-index: 5; 
    border: 1px solid var(--moving-color);
  }
  @media (max-width:760px){
    h1{font-size:2.5rem; letter-spacing:1px; margin-bottom: 10px;}
    .pod{ width:100px; min-height:100px; padding: 18px 10px 10px; }
    .pod.first, .pod.second, .pod.third { transform: none; }
    .pod .place { font-size: 1.5rem; top: -15px; }
    .pod .name { font-size: 0.8rem; }
    .pod .points { font-size: 0.9rem; }
    tbody td { font-size: 0.85rem; padding: 10px 5px;}
    thead th { font-size: 0.75rem; padding: 10px 5px;}
  }
  .muted{opacity:0.9;font-weight:500;font-size:0.9rem;}
</style>
</head>
<body>
<h1>EIF LEADERBOARD</h1> 

<div class="podium-wrap">
  <div class="podium" id="podium">
    <div class="pod second" data-place="2"><div class="place">2nd ðŸ¥ˆ</div><div class="name muted">â€”</div><div class="points">0 pts</div></div>
    <div class="pod first" data-place="1"><div class="place">1st ðŸ¥‡</div><div class="name muted">â€”</div><div class="points">0 pts</div></div>
    <div class="pod third" data-place="3"><div class="place">3rd ðŸ¥‰</div><div class="name muted">â€”</div><div class="points">0 pts</div></div>
  </div>
</div>

<div class="table-wrap">
  <table id="leaderboard" aria-label="Leaderboard">
    <thead></thead>
    <tbody></tbody>
  </table>
</div>

<script>
const SHEET_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vTQi-z2SLLIg21-uohF1NG58lzZZuPZ6V_wGuQ_g-PTmjvRHcUR3e6PPg4K80i7_Qia_YZkDIJS2eCL/pub?gid=0&single=true&output=csv";
const POLL_MS = 10000;

const tableHead = document.querySelector("#leaderboard thead");
const tableBody = document.querySelector("#leaderboard tbody");
const podium = document.getElementById("podium");

// --- Persistent state to prevent reversion ---
let leaderboardState = new Map(); // key -> {rowData, points, rank}

// --- CSV parsing ---
function parseCSV(text){
  const rows=[], row=[], cur="", inQuotes=false;
  let r=[], c="";
  let newRow=[], curVal="", inQuotesFlag=false;
  let i=0;
  rowsArr = [];
  let tempRow=[], tempVal="";
  let inQ=false;
  let rowArr=[];
  let rowsData=[];
  const rows2=[];
  let current="", row2=[], inQuotes2=false;
  let rcur="", rrow=[], rinQuotes=false;
  for (let i=0;i<text.length;i++){
    const ch=text[i], next=text[i+1];
    if(ch==='"'){
      if(inQuotes2 && next==='"'){ rcur+='"'; i++; } else { inQuotes2=!inQuotes2; }
    } else if(ch===',' && !inQuotes2){ rrow.push(rcur); rcur=""; }
    else if((ch==='\n'||(ch==='\r'&&text[i+1]==='\n')) && !inQuotes2){
      if(ch==='\r'&&text[i+1]==='\n'){ i++; }
      rrow.push(rcur); rows2.push(rrow.map(c=>c.trim())); rrow=[]; rcur="";
    } else { rcur+=ch; }
  }
  if(rcur!==""||rrow.length>0){ rrow.push(rcur); rows2.push(rrow.map(c=>c.trim())); }
  return rows2.filter(r=>r.length>0 && r.some(c=>c!==""));
}

// --- Detect points column ---
function detectPointsColumn(headers, rows){
  const normalized = headers.map(h=>(h||"").toLowerCase().replace(/[^a-z0-9]/g, ''));
  const candidates = ['total','points','score','pts'];
  for(let c of candidates){
    const idx = normalized.indexOf(c);
    if(idx!==-1) return idx;
  }
  if(rows.length > 0) {
    for (let i = headers.length - 1; i >= 0; i--) {
        let numberCount = 0;
        rows.forEach(row => {
            const v = (row[i] || '').toString().replace(/[^0-9.\-]/g, '').trim();
            if (v !== '' && !isNaN(Number(v))) numberCount++;
        });
        if (numberCount / rows.length > 0.5) return i;
    }
  }
  return headers.length > 0 ? headers.length - 1 : 0;
}

// --- Build table header ---
function buildHeader(headers, ptsIdx){
  const tr=document.createElement('tr');
  const rankTh=document.createElement('th'); rankTh.textContent='Rank'; tr.appendChild(rankTh);
  headers.forEach((h, i) => { 
    const normalizedH = (h||'').toLowerCase().replace(/[^a-z0-9]/g, '');
    if (i !== ptsIdx && normalizedH !== 'rank' && normalizedH !== 'no') {
      const th=document.createElement('th'); 
      th.textContent=h||'â€”'; 
      tr.appendChild(th); 
    }
  });
  const ptsHeader = headers[ptsIdx] || 'Points';
  const ptsTh=document.createElement('th'); 
  ptsTh.textContent = ptsHeader;
  tr.appendChild(ptsTh);
  tableHead.innerHTML=""; 
  tableHead.appendChild(tr);
}

// --- Fetch CSV ---
async function fetchSheetCSV(){
  const url=SHEET_URL+(SHEET_URL.includes('?')?'&':'?')+'_='+Date.now();
  const resp=await fetch(url,{
    cache:"no-store",
    headers: {'Cache-Control': 'no-cache, no-store, must-revalidate'}
  }); 
  if(!resp.ok) throw new Error("Failed to fetch sheet: "+resp.status);
  return parseCSV(await resp.text());
}

// --- Generate player key ---
function playerKeyFromRow(headers, row, nameIdx, ptsIdx){
  const normalized = headers.map(h=>(h||"").toLowerCase().replace(/[^a-z0-9]/g, ''));
  const candidates = ['id','player','name','team'];
  for(let c of candidates){
    const idx=normalized.indexOf(c); 
    if(idx!==-1 && row[idx]) return row[idx];
  }
  if(nameIdx !== -1 && row[nameIdx] && nameIdx !== ptsIdx) return row[nameIdx];
  for(let i = 0; i < row.length; i++) {
      if (i !== ptsIdx && row[i] && row[i].trim() !== '') return row[i];
  }
  return JSON.stringify(row);
}

// --- Animate and render table ---
function animateReorderAndRender(newOrderedRows, nameIdx, ptsIdx, headers){
  const oldElements={};
  Array.from(tableBody.children).forEach(tr=>{ const key=tr.dataset.key; if(key) oldElements[key]=tr; });
  const oldRects={};
  Object.entries(oldElements).forEach(([k,el])=>{ oldRects[k]=el.getBoundingClientRect(); });
  const frag=document.createDocumentFragment();

  newOrderedRows.forEach(item=>{
    const {key,rowData,rank}=item;
    let tr=oldElements[key];
    const prevData = leaderboardState.get(key);

    const prevPoints = prevData ? prevData.points : null;
    const rankMoved = prevData && prevData.rank !== rank;

    if(!tr){ 
      tr=document.createElement('tr'); 
      tr.dataset.key=key;
      tr.classList.add('updated-cell');
      setTimeout(()=>tr.classList.remove('updated-cell'),3000);
    } else {
      tr.classList.remove('updated-cell','moving');
      if(tr._flashTimeout) clearTimeout(tr._flashTimeout);
    }

    tr.innerHTML="";
    const rankTd=document.createElement('td'); rankTd.textContent=rank; tr.appendChild(rankTd);

    rowData.forEach((cellVal, i)=>{
      if(i!==ptsIdx){
        const normalizedH = (headers[i]||'').toLowerCase().replace(/[^a-z0-9]/g,'');
        if(normalizedH!=='rank' && normalizedH!=='no'){
          const td=document.createElement('td'); td.textContent=cellVal; tr.appendChild(td);
        }
      }
    });

    const ptsTd=document.createElement('td'); ptsTd.textContent=rowData[ptsIdx] || '0'; tr.appendChild(ptsTd);

    if(prevPoints !== null && prevPoints !== Number(rowData[ptsIdx])){
      tr.classList.add('updated-cell');
      tr._flashTimeout=setTimeout(()=>tr.classList.remove('updated-cell'),3000);
    }

    frag.appendChild(tr);
  });

  tableBody.innerHTML=""; tableBody.appendChild(frag);
}

// --- Render podium ---
function renderPodium(top3){
  const rankTexts = ['1st ðŸ¥‡', '2nd ðŸ¥ˆ', '3rd ðŸ¥‰'];
  const pods=[podium.querySelector('.pod.second'),podium.querySelector('.pod.first'),podium.querySelector('.pod.third')];
  const dataMap=[top3[1],top3[0],top3[2]]; 
  const textMap = [rankTexts[1], rankTexts[0], rankTexts[2]];

  for(let i=0;i<3;i++){
    const pod=pods[i],data=dataMap[i]; 
    if(!pod) continue;
    const placeEl=pod.querySelector('.place');
    const nameEl=pod.querySelector('.name'), pointsEl=pod.querySelector('.points');

    placeEl.innerHTML = textMap[i] || `${i+1}th`; 

    if(data){ 
      let displayName = data.name || 'â€”'; 
      nameEl.textContent=displayName; 
      nameEl.classList.remove('muted'); 
      pointsEl.textContent=(data.points!=null?data.points:'0')+' pts'; 
    } else { 
      nameEl.textContent='â€”'; 
      nameEl.classList.add('muted'); 
      pointsEl.textContent='0 pts'; 
    }
  }
}

// --- Process and render ---
function processAndRender(allRows){
  if(!allRows || allRows.length<1) return;
  const headers = allRows[0].map(h=>h||''); 
  const rawRows = allRows.slice(1).filter(r=>r.some(c=>c.trim()!==""));
  const ptsIdx = detectPointsColumn(headers, rawRows);

  let nameIdx=-1;
  const normalizedHeaders = headers.map(h=>(h||'').toLowerCase().replace(/[^a-z0-9]/g,''));
  const nameCandidates = ['name','player','team','id'];
  for(let c of nameCandidates){
    const idx = normalizedHeaders.indexOf(c);
    if(idx!==-1){ nameIdx=idx; break; }
  }
  if(nameIdx===-1 || nameIdx===ptsIdx) nameIdx = 0;

  const rowObjs = rawRows.map(row=>{
    const ptsRaw=(row[ptsIdx]||'').toString().replace(/[^0-9.\-]/g,'').trim();
    const points = ptsRaw===''||isNaN(Number(ptsRaw)) ? 0 : Number(ptsRaw);
    const name = (row[nameIdx]||'').toString();
    const key = playerKeyFromRow(headers,row,nameIdx,ptsIdx);
    return {key,name,points,rowData:row};
  });

  rowObjs.sort((a,b)=>{ if(b.points!==a.points) return b.points-a.points; return a.name.localeCompare(b.name); });

  let rank=0, lastPoints=null;
  rowObjs.forEach((r,idx)=>{
    if(lastPoints===null||r.points!==lastPoints){ rank=idx+1; lastPoints=r.points; }
    r.rank=rank;
  });

  buildHeader(headers, ptsIdx);
  animateReorderAndRender(rowObjs.map(r=>({key:r.key,rowData:r.rowData,rank:r.rank})), nameIdx, ptsIdx, headers);
  renderPodium(rowObjs.slice(0,3).map(r=>({name:r.name, points:r.points})));

  // --- Update global leaderboard state ---
  rowObjs.forEach(r=>{
    leaderboardState.set(r.key,{rowData:r.rowData.slice(), points:r.points, rank:r.rank});
  });
}

// --- Update leaderboard ---
async function updateLeaderboard(){
  try{
    const csv=await fetchSheetCSV();
    if(!csv || csv.length<=1){ 
      tableHead.innerHTML="<tr><th>No data found</th></tr>"; 
      tableBody.innerHTML=""; 
      renderPodium([]); 
      return; 
    }
    processAndRender(csv);
  }catch(err){ console.error("ðŸ›‘ Failed to update leaderboard:",err); }
}

// --- Initial load + interval ---
updateLeaderboard();
setInterval(updateLeaderboard,POLL_MS);
</script>
</body>
</html>
