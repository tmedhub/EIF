<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>EIF Leaderboard</title>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
<style>
  :root{
    --bg1: #ff8a00;
    --bg2: #ffd24d;
    --glass: rgba(255,255,255,0.08);
    --glass-2: rgba(255,255,255,0.12);
    --accent: rgba(255,255,255,0.95);
    --update-glow: rgba(0,255,0,0.22);
  }
  html,body{height:100%;margin:0;}
  body{
    min-height:100%;
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:20px;
    font-family: "Poppins", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    color:var(--accent);
    padding:28px;
    background: linear-gradient(135deg, var(--bg1) 0%, var(--bg2) 60%);
    background-attachment: fixed;
  }
  h1{
    margin:0;
    font-size:2rem;
    letter-spacing:2px;
    text-transform:uppercase;
    display:flex;
    align-items:center;
    gap:12px;
  }
  .podium-wrap{
    width:90%;
    max-width:1000px;
    display:flex;
    justify-content:center;
    align-items:flex-end;
    gap:18px;
    padding:10px;
  }
  .podium{
    display:flex;
    gap:16px;
    align-items:flex-end;
    width:100%;
    justify-content:center;
    max-width:900px;
    margin-bottom:6px;
  }
  .pod{
    width:180px;
    min-height:110px;
    border-radius:12px;
    background: linear-gradient(180deg, rgba(255,255,255,0.12), rgba(255,255,255,0.04));
    box-shadow: 0 8px 30px rgba(0,0,0,0.25);
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:flex-end;
    padding:12px;
    position:relative;
    transform-origin: bottom center;
    transition: transform 300ms ease;
  }
  .pod .place{
    font-weight:700;
    font-size:1.2rem;
    margin-bottom:6px;
  }
  .pod .name{
    font-weight:600;
    font-size:1rem;
    white-space:nowrap;
    text-overflow:ellipsis;
    overflow:hidden;
    width:100%;
    text-align:center;
  }
  .pod .points{
    font-size:0.95rem;
    margin-top:6px;
    background: rgba(0,0,0,0.18);
    padding:6px 8px;
    border-radius:8px;
    font-weight:700;
  }
  .pod.first{ height:180px; transform: translateY(-10px) scale(1.04); border: 3px solid rgba(255,255,255,0.14); }
  .pod.second{ height:150px; transform: translateY(0) scale(1.00); }
  .pod.third{ height:130px; transform: translateY(6px) scale(.98); }
  .table-wrap{
    width: 90%;
    max-width: 1000px;
    background: linear-gradient(180deg, rgba(0,0,0,0.12), rgba(0,0,0,0.06));
    border-radius:14px;
    padding:10px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.25);
  }
  table{
    width:100%;
    border-collapse: collapse;
    overflow: hidden;
    color:var(--accent);
    table-layout:auto;
  }
  thead th{
    background: rgba(255,255,255,0.06);
    padding:12px 10px;
    text-transform:uppercase;
    font-size:0.85rem;
    letter-spacing:1px;
    text-align:center;
    border-bottom:1px solid rgba(255,255,255,0.06);
  }
  tbody td{
    padding:12px 10px;
    text-align:center;
    border-bottom:1px dashed rgba(255,255,255,0.04);
    font-size:0.95rem;
    vertical-align:middle;
  }
  tbody tr{
    transition: transform 500ms ease, background-color 220ms ease;
    will-change: transform;
  }
  tbody tr.updated-cell td.changed {
    animation: cell-glow 1.2s ease;
  }
  @keyframes cell-glow {
    0% { background-color: var(--update-glow); }
    100% { background-color: transparent; }
  }
  .moving {
    box-shadow: 0 8px 24px rgba(0,0,0,0.25);
    border-radius:8px;
    background: rgba(255,255,255,0.02);
  }
  @media (max-width:760px){
    .pod{ width:120px; min-height:90px; }
    .pod.first{height:140px;}
    .pod.second{height:120px;}
    .pod.third{height:110px;}
    h1{font-size:1.2rem;}
  }
  .muted{opacity:0.9;font-weight:600;font-size:0.9rem;}
</style>
</head>
<body>
<h1>EIF Leaderboard</h1> 

<div class="podium-wrap">
  <div class="podium" id="podium">
    <div class="pod second" data-place="2"><div class="place">2</div><div class="name muted">â€”</div><div class="points">0 pts</div></div>
    <div class="pod first" data-place="1"><div class="place">1</div><div class="name muted">â€”</div><div class="points">0 pts</div></div>
    <div class="pod third" data-place="3"><div class="place">3</div><div class="name muted">â€”</div><div class="points">0 pts</div></div>
  </div>
</div>

<div class="table-wrap">
  <table id="leaderboard" aria-label="Leaderboard">
    <thead></thead>
    <tbody></tbody>
  </table>
</div>

<script>
// IMPORTANT: Use your correct public Google Sheet URL here
const SHEET_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vTQi-z2SLLIg21-uohF1NG58lzZZuPZ6V_wGuQ_g-PTmjvRHcUR3e6PPg4K80i7_Qia_YZkDIJS2eCL/pub?gid=0&single=true&output=csv";

const tableHead = document.querySelector("#leaderboard thead");
const tableBody = document.querySelector("#leaderboard tbody");
const podium = document.getElementById("podium");
let previousRowsMap = new Map();
let previousOrder = [];
const POLL_MS = 15000;

function parseCSV(text){
  const rows = [];
  let cur="", row=[], inQuotes=false;
  for (let i=0;i<text.length;i++){
    const ch=text[i], next=text[i+1];
    if(ch==='"'){
      if(inQuotes && next==='"'){ cur+='"'; i++; } else { inQuotes=!inQuotes; }
    } else if(ch===',' && !inQuotes){ row.push(cur); cur=""; }
    else if((ch==='\n'||(ch==='\r'&&text[i+1]==='\n')) && !inQuotes){
      if(ch==='\r'&&text[i+1]==='\n'){ i++; }
      row.push(cur); rows.push(row.map(c=>c.trim())); row=[]; cur="";
    } else { cur+=ch; }
  }
  if(cur!==""||row.length>0){ row.push(cur); rows.push(row.map(c=>c.trim())); }
  return rows.filter(r=>r.length>0 && r.some(c=>c!==""));
}

function detectPointsColumn(headers, rows){
  const normalized = headers.map(h=>(h||"").toLowerCase());
  const candidates = ['total','points','score','pts'];
  // 1. Check for header candidates first
  for(let c of candidates){
    const idx = normalized.indexOf(c);
    if(idx!==-1) return idx;
  }
  // 2. Fallback: check if a column looks like numbers (more than 50% are numbers)
  if(rows.length > 0) {
    for (let i = headers.length - 1; i >= 0; i--) {
        let numberCount = 0;
        rows.forEach(row => {
            const v = (row[i] || '').toString().replace(/[^0-9.\-]/g, '').trim();
            if (v !== '' && !isNaN(Number(v))) {
                numberCount++;
            }
        });
        // If more than 50% of the rows in this column are numbers, assume it's the points column
        if (numberCount / rows.length > 0.5) {
            return i;
        }
    }
  }
  // 3. Absolute fallback: assume the last column
  return headers.length > 0 ? headers.length - 1 : 0;
}

async function fetchSheetCSV(){
  const url=SHEET_URL+(SHEET_URL.includes('?')?'&':'?')+'_='+Date.now();
  const resp=await fetch(url,{cache:"no-store"});
  if(!resp.ok) throw new Error("Failed to fetch sheet: "+resp.status);
  return parseCSV(await resp.text());
}

function buildHeader(headers){
  const tr=document.createElement('tr');
  const rankTh=document.createElement('th'); rankTh.textContent='Rank'; tr.appendChild(rankTh);
  headers.forEach(h=>{ const th=document.createElement('th'); th.textContent=h||'-'; tr.appendChild(th); });
  tableHead.innerHTML=""; tableHead.appendChild(tr);
}

function playerKeyFromRow(headers, row, nameIdx, ptsIdx){
  const normalized = headers.map(h=>(h||"").toLowerCase());
  const candidates = ['id','player','name','team'];
  
  // 1. Prioritize a column with a clear ID/Name header
  for(let c of candidates){
    const idx=normalized.indexOf(c); 
    if(idx!==-1 && row[idx]) return row[idx];
  }
  
  // 2. Fallback: Use the determined Name column index if it exists and is not the points column
  if(nameIdx !== -1 && row[nameIdx] && nameIdx !== ptsIdx) return row[nameIdx];
  
  // 3. Last fallback: Use the very first non-empty cell that isn't the points column
  for(let i = 0; i < row.length; i++) {
      if (i !== ptsIdx && row[i] && row[i].trim() !== '') {
          return row[i];
      }
  }

  return JSON.stringify(row); // Use all data as a key if no specific name/ID is found
}

function animateReorderAndRender(newOrderedRows){
  const oldElements={};
  Array.from(tableBody.children).forEach(tr=>{ const key=tr.dataset.key; if(key) oldElements[key]=tr; });
  const oldRects={};
  Object.entries(oldElements).forEach(([k,el])=>{ oldRects[k]=el.getBoundingClientRect(); });
  const frag=document.createDocumentFragment();
  newOrderedRows.forEach(item=>{
    const {key,rowData}=item;
    let tr=oldElements[key];
    if(!tr){ tr=document.createElement('tr'); tr.dataset.key=key; } else { tr.classList.remove('updated-cell'); }
    tr.innerHTML="";
    const rankTd=document.createElement('td'); rankTd.textContent=item.rank; tr.appendChild(rankTd);
    rowData.forEach(cellVal=>{ const td=document.createElement('td'); td.textContent=cellVal; tr.appendChild(td); });
    const prevRow=previousRowsMap.get(key)||[];
    if(prevRow.length){
      const tds=tr.querySelectorAll('td');
      let changed=false;
      for(let i=1;i<tds.length;i++){
        const prevVal=prevRow[i-1]||"", curVal=rowData[i-1]||"";
        if(prevVal!==curVal){ tds[i].classList.add('changed'); changed=true; }
      }
      const prevRank=previousOrder.indexOf(key)+1;
      if(prevRank!==item.rank && item.rank>0 && prevRank>0){ changed=true; }
      if(changed) tr.classList.add('updated-cell');
    }
    frag.appendChild(tr);
  });
  tableBody.innerHTML=""; tableBody.appendChild(frag);
  const newRects={};
  Array.from(tableBody.children).forEach(tr=>{ const key=tr.dataset.key; newRects[key]=tr.getBoundingClientRect(); });
  Object.entries(newRects).forEach(([k,newRect])=>{
    const el=tableBody.querySelector(`tr[data-key='${CSS.escape(k)}']`);
    const oldRect=oldRects[k];
    if(oldRect){
      const dy=oldRect.top-newRect.top;
      if(dy!==0){
        el.style.transform=`translateY(${dy}px)`; el.classList.add('moving'); el.getBoundingClientRect();
        requestAnimationFrame(()=>{
          el.style.transition='transform 500ms cubic-bezier(.2,.8,.2,1)';
          el.style.transform='';
          el.addEventListener('transitionend',function onEnd(e){
            if(e.propertyName==='transform'){ el.classList.remove('moving'); el.style.transition=''; el.removeEventListener('transitionend',onEnd); }
          });
        });
      }
    }
  });
  setTimeout(()=>{
    Array.from(tableBody.querySelectorAll('tr.updated-cell')).forEach(tr=>{
      tr.classList.remove('updated-cell');
      tr.querySelectorAll('td.changed').forEach(td=> td.classList.remove('changed'));
    });
  },1400);
}

function renderPodium(top3){
  // Note: Pods are ordered: Second, First, Third in the HTML
  const pods=[podium.querySelector('.pod.second'),podium.querySelector('.pod.first'),podium.querySelector('.pod.third')];
  // Data map is indexed: 1st place, 2nd place, 3rd place from the sorted array
  const dataMap=[top3[1],top3[0],top3[2]]; 
  
  // Render based on the sorted order
  for(let i=0;i<3;i++){
    const pod=pods[i],data=dataMap[i]; if(!pod) continue;
    const nameEl=pod.querySelector('.name'), pointsEl=pod.querySelector('.points');
    
    if(data){ 
      // Use the name property, which is set to rowData[nameIdx]
      let displayName = data.name || 'â€”'; 
      
      nameEl.textContent=displayName; 
      nameEl.classList.remove('muted'); 
      pointsEl.textContent=(data.points!=null?data.points:'0')+' pts'; 
    }
    else{ 
      nameEl.textContent='â€”'; 
      pointsEl.textContent='0 pts'; 
      nameEl.classList.add('muted'); 
    }
  }
}

function processAndRender(allRows){
  if(!allRows||allRows.length<1) return;
  const headers=allRows[0].map(h=>h||'').filter(h => h !== ''); // Filter out empty header cells
  const rawRows=allRows.slice(1).filter(r=>r.some(c=>c.trim()!==""));
  
  const ptsIdx=detectPointsColumn(headers,rawRows);
  
  let nameIdx = -1;
  const normalizedHeaders = headers.map(h => (h || "").toLowerCase());
  const nameCandidates = ['name', 'player', 'team', 'id'];

  // 1. Find name column by header
  for (let c of nameCandidates) {
    const idx = normalizedHeaders.indexOf(c);
    if (idx !== -1) {
      nameIdx = idx;
      break;
    }
  }
  
  // 2. Fallback: If no clear header or the header is the points column, find the first non-points column
  if (nameIdx === -1 || nameIdx === ptsIdx) {
    nameIdx = headers.findIndex((_, i) => i !== ptsIdx);
    if (nameIdx === -1) nameIdx = 0; // Absolute fallback
  }

  // Final check: if name and points are the same column, we have a problem, but stick to the best guess.
  if (nameIdx === ptsIdx && headers.length > 1) {
      console.warn("Name and Points column are the same! Defaulting name to column 0.");
      nameIdx = 0; // Force name to the first column (assuming points are elsewhere)
  }
  
  const rowObjs=rawRows.map(row=>{
    const ptsRaw=(row[ptsIdx]||'').toString().replace(/[^0-9.\-]/g,'').trim();
    const points=ptsRaw===''||isNaN(Number(ptsRaw))?0:Number(ptsRaw);
    const name=(row[nameIdx]||'').toString(); // Use the determined name index
    const key=playerKeyFromRow(headers,row, nameIdx, ptsIdx);
    return { key, name, points, rowData:row };
  });
  
  rowObjs.sort((a,b)=>{ if(b.points!==a.points) return b.points-a.points; return a.name.localeCompare(b.name); });
  let rank=0, lastPoints=null;
  rowObjs.forEach((r,idx)=>{ if(lastPoints===null||r.points!==lastPoints){ rank=idx+1; lastPoints=r.points; } r.rank=rank; });
  
  buildHeader(headers);
  const newOrderedRows=rowObjs.map(r=>({ key:r.key,rowData:r.rowData,rank:r.rank }));
  animateReorderAndRender(newOrderedRows);
  renderPodium(rowObjs.slice(0,3).map(r=>({ name:r.name, points:r.points })));
  previousRowsMap.clear(); rowObjs.forEach(r=>previousRowsMap.set(r.key,r.rowData.slice())); previousOrder=rowObjs.map(r=>r.key);
}

async function updateLeaderboard(){
  try{
    console.log(`Fetching data from sheet...`);
    const csv=await fetchSheetCSV();
    console.log(`Data fetched successfully. Rows: ${csv.length}`);
    if(!csv||csv.length<=1){ tableHead.innerHTML="<tr><th>No data found or only header row</th></tr>"; tableBody.innerHTML=""; renderPodium([]); return; }
    processAndRender(csv);
  }catch(err){ console.error("ðŸ›‘ Failed to update leaderboard:",err); }
}

updateLeaderboard();
setInterval(updateLeaderboard,POLL_MS);
</script>
</body>
</html>
