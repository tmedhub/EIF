<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>EIF Leaderboard</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700;800&display=swap" rel="stylesheet">
  <style>
    /* Page - VIBRANT GRADIENT & MOBILE FOCUS */
    :root{
      /* Primary Colors */
      --bg1: #ff8a00; /* Orange */
      --bg2: #ffd24d; /* Yellow */
      --bg-page: #f9f9f9; /* Near-white background outside the card */
      
      /* Card & Text */
      --card-bg: #ffffff;
      --text-dark: #333333;
      --rank-color: #ff5722; /* Deep Orange for Rank */
      --update-glow: rgba(0,255,0,0.4);
    }
    html,body{height:100%;margin:0;}
    body{
      min-height:100%;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:0; 
      font-family: "Poppins", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      color:var(--text-dark);
      background: var(--bg-page);
      padding:0;
      width: 100%;
    }
    
    /* === MAIN CONTAINER (The full orange/yellow background) === */
    .main-container {
      width: 100%;
      max-width: 480px; /* Constrain max width for mobile feel */
      min-height: 100vh;
      background: linear-gradient(180deg, var(--bg2) 0%, var(--bg1) 100%);
      box-shadow: 0 0 30px rgba(0,0,0,0.1);
      padding-bottom: 30px;
      position: relative;
    }

    h1{
      margin: 0;
      padding: 40px 20px 0;
      font-size:2rem;
      letter-spacing:2px;
      text-transform:uppercase;
      text-align: center;
      color: #fff;
      font-weight: 800;
      text-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    /* === PODIUM SECTION (Top 3) === */
    .podium-wrap{
      padding: 30px 20px 20px;
      display:flex;
      justify-content:center;
      align-items:flex-end;
      width: 100%;
      max-width: 480px;
      gap:10px;
    }
    .pod{
      width: 32%; /* Distribute width */
      display:flex;
      flex-direction:column;
      align-items:center;
      color: #fff;
      text-shadow: 0 1px 2px rgba(0,0,0,0.2);
      position:relative;
      transition: transform 300ms ease;
    }
    .pod .icon{
      font-size: 3rem;
      margin-bottom: 5px;
      filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
    }
    .pod.first .icon { color: #fff; font-size: 4rem; margin-bottom: 0; }
    .pod.second .icon { color: #c0c0c0; }
    .pod.third .icon { color: #cd7f32; }
    
    .pod .name{
      font-weight:600;
      font-size:0.9rem;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      width: 90%;
      text-align:center;
    }
    .pod .points{
      font-size:0.8rem;
      font-weight:400;
    }
    .pod .place { display: none; } /* Hide text rank number */
    
    /* === LEADERBOARD LIST (The Cards) === */
    .table-wrap{
      width: 100%;
      padding: 0 20px;
      box-sizing: border-box;
    }
    #leaderboard{
      display: block; 
      width: 100%;
    }
    #leaderboard thead { display: none; } /* Hide all table headers */
    
    #leaderboard tbody {
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding: 0;
      margin: 0;
    }
    
    tbody tr{
      display: flex;
      width: 100%;
      background: var(--card-bg);
      border-radius: 40px 10px 10px 40px; /* Shaped card borders */
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      height: 65px;
      align-items: center;
      transition: transform 500ms ease, box-shadow 500ms ease;
      border-left: 5px solid transparent;
    }
    
    /* FLIP move highlight */
    .moving {
      box-shadow: 0 8px 20px rgba(0,0,0,0.3);
      border-color: var(--rank-color);
      z-index: 10;
      position: relative;
    }

    /* Cells inside the row are the card components */
    tbody td {
      display: flex;
      padding: 0;
      margin: 0;
      height: 100%;
      align-items: center;
      justify-content: center;
      border: none; /* Remove table cell borders */
      background: none;
      min-width: 0;
    }

    /* Rank (First TD) */
    tbody td:nth-child(1) {
      background: var(--rank-color);
      color: #fff;
      width: 35px;
      border-radius: 40px 0 0 40px;
      font-size: 1.1rem;
      font-weight: 800;
      flex-shrink: 0;
    }
    
    /* Avatar (Second TD - Placeholder for the Name column from the sheet) */
    tbody td:nth-child(2) {
      width: 45px;
      flex-shrink: 0;
      margin-left: 10px;
    }
    .avatar-placeholder {
      width: 45px;
      height: 45px;
      background: #ccc; 
      border-radius: 50%;
      overflow: hidden;
      border: 2px solid var(--bg1);
    }
    .avatar-placeholder::after {
      content: '👤'; 
      font-size: 1.8rem;
      line-height: 45px;
      color: #fff;
    }

    /* Player Name (Third TD) */
    tbody td:nth-child(3) {
      justify-content: flex-start;
      padding-left: 15px;
      font-weight: 700;
      flex-grow: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Points/Data Columns (Remaining TDs) */
    tbody td:last-child {
      font-weight: 800;
      color: var(--text-dark);
      padding-right: 20px;
      flex-shrink: 0;
      border-radius: 0 10px 10px 0;
      background: var(--bg2); 
      height: 100%;
      width: 80px;
    }
    
    /* Animation glow for updated cells */
    @keyframes cell-glow {
      0% { box-shadow: 0 0 10px 2px var(--update-glow); }
      100% { box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
    }
    tbody tr.updated-cell {
      animation: cell-glow 1.2s ease forwards;
    }
  </style>
</head>
<body>
  <div class="main-container">
        <h1>EIF Leaderboard</h1>

        <div class="podium-wrap">
      <div class="podium" id="podium">
                <div class="pod second" data-place="2">
          <div class="icon">🥈</div>
          <div class="name muted">—</div>
          <div class="points">0</div>
        </div>
                <div class="pod first" data-place="1">
          <div class="icon">🏆</div>
          <div class="name muted">—</div>
          <div class="points">0</div>
        </div>
                <div class="pod third" data-place="3">
          <div class="icon">🥉</div>
          <div class="name muted">—</div>
          <div class="points">0</div>
        </div>
      </div>
    </div>

        <div class="table-wrap">
      <table id="leaderboard" aria-label="Leaderboard">
        <thead></thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <script>
    /*        === CONFIG ===
       The working public CSV URL.
    */
    const SHEET_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vTQi-z2SLLIg21-uohF1NG58lzZZuPZ6V_wGuQ_g-PTmjvRHcUR3e6PPg4K80i7_Qia_YZkDIJS2eCL/pub?gid=0&single=true&output=csv";

    const tableHead = document.querySelector("#leaderboard thead");
    const tableBody = document.querySelector("#leaderboard tbody");
    const podium = document.getElementById("podium");

    // store previous state for change detection and FLIP
    let previousRowsMap = new Map();
    let previousOrder = [];

    const POLL_MS = 15000; // 15 seconds for updates

    /* -- utility: robust CSV parser (intact) -- */
    function parseCSV(text){
      const rows = [];
      let cur = "";
      let row = [];
      let inQuotes = false;
      for (let i = 0; i < text.length; i++){
        const ch = text[i];
        const next = text[i+1];
        if (ch === '"' ){
          if (inQuotes && next === '"'){
            cur += '"'; 
            i++;
          } else {
            inQuotes = !inQuotes;
          }
        } else if (ch === ',' && !inQuotes){
          row.push(cur);
          cur = "";
        } else if ((ch === '\n' || (ch === '\r' && text[i+1] === '\n')) && !inQuotes){
          if (ch === '\r' && text[i+1] === '\n') { i++; }
          row.push(cur);
          rows.push(row.map(c => c.trim()));
          row = [];
          cur = "";
        } else {
          cur += ch;
        }
      }
      if (cur !== "" || row.length > 0){
        row.push(cur);
        rows.push(row.map(c => c.trim()));
      }
      return rows.filter(r => r.length > 0 && r.some(cell => cell !== ""));
    }

    /* -- auto-detect points column index (intact) -- */
    function detectPointsColumn(headers, rows){
      const normalized = headers.map(h => (h||"").toString().toLowerCase());
      const candidates = ['total','points','score','pts'];
      for (let c of candidates){
        const idx = normalized.indexOf(c);
        if (idx !== -1) return idx;
      }
      if (rows.length > 0){
        const firstRow = rows[0];
        for (let i = firstRow.length - 1; i >= 0; i--){
          const v = firstRow[i].replace(/[^0-9.\-]/g,"");
          if (v !== "" && !isNaN(Number(v))) return i;
        }
      }
      return headers.length - 1;
    }

    /* -- CSV fetch with cache busting (intact) -- */
    async function fetchSheetCSV(){
      const url = SHEET_URL + (SHEET_URL.includes('?') ? '&' : '?') + '_=' + Date.now();
      const resp = await fetch(url, {cache: "no-store"});
      if (!resp.ok) throw new Error("Failed to fetch sheet: " + resp.status);
      const text = await resp.text();
      return parseCSV(text);
    }

    /* -- Create table header (minimal for JS structure) -- */
    function buildHeader(headers){
      const tr = document.createElement('tr');
      const rankTh = document.createElement('th');
      rankTh.textContent = 'Rank';
      tr.appendChild(rankTh);
      headers.forEach(h => {
        const th = document.createElement('th');
        th.textContent = h || '-';
        tr.appendChild(th);
      });
      tableHead.innerHTML = "";
      tableHead.appendChild(tr);
    }

    /* -- Utility to get unique player id (intact) -- */
    function playerKeyFromRow(headers, row){
      const normalized = headers.map(h => (h||"").toString().toLowerCase());
      const nameIdxCandidates = ['id','player','name','team'];
      for (let c of nameIdxCandidates){
        const idx = normalized.indexOf(c);
        if (idx !== -1 && row[idx]) return row[idx];
      }
      if (row.length >= 2 && row[1]) return row[1];
      return JSON.stringify(row);
    }

    /* -- FLIP animation and rendering (FIXED for card structure) -- */
    function animateReorderAndRender(newOrderedRows, ptsIdx, nameIdx){
      const oldElements = {};
      Array.from(tableBody.children).forEach(tr => {
        const key = tr.dataset.key;
        if (key) oldElements[key] = tr;
      });

      const oldRects = {};
      Object.entries(oldElements).forEach(([k, el]) => {
        oldRects[k] = el.getBoundingClientRect();
      });

      const frag = document.createDocumentFragment();
      newOrderedRows.forEach(item => {
        const {key, rowData} = item;
        let tr = oldElements[key];
        
        if (!tr){
          tr = document.createElement('tr');
          tr.dataset.key = key;
        } else {
          tr.classList.remove('updated-cell');
        }
        
        tr.innerHTML = "";

        // Extract data needed for card: Name and Points
        const name = rowData[nameIdx] || '—';
        const pointsRaw = (rowData[ptsIdx]||'0').replace(/[^0-9.\-]/g,'');
        const points = Number(pointsRaw).toLocaleString('en-US');
        
        // --- START: Build Card TDs (4 total) ---

        // 1. Rank cell (TD 1)
        const rankTd = document.createElement('td');
        rankTd.textContent = item.rank;
        tr.appendChild(rankTd);

        // 2. Avatar Cell (TD 2)
        const avatarTd = document.createElement('td');
        avatarTd.innerHTML = '<div class="avatar-placeholder"></div>';
        tr.appendChild(avatarTd);

        // 3. Name Cell (TD 3)
        const nameTd = document.createElement('td');
        nameTd.textContent = name;
        tr.appendChild(nameTd);

        // 4. Points Cell (TD 4)
        const pointsTd = document.createElement('td');
        pointsTd.textContent = points;
        tr.appendChild(pointsTd);
        
        // --- END: Build Card TDs ---

        // Check for changes to trigger the glow animation
        const prevRow = previousRowsMap.get(key) || [];
        let changed = false;
        if (prevRow.length){
          const prevPts = Number((prevRow[ptsIdx]||'0').replace(/[^0-9.\-]/g,''));
          if (Number(pointsRaw) !== prevPts || prevRow[nameIdx] !== name){
            changed = true;
          }
          const prevRank = previousOrder.indexOf(key) + 1;
          if (prevRank !== item.rank && item.rank > 0 && prevRank > 0){
            changed = true;
          }
          if (changed) tr.classList.add('updated-cell');
        }

        frag.appendChild(tr);
      });

      tableBody.innerHTML = "";
      tableBody.appendChild(frag);

      // Measure new rects and apply FLIP transforms (intact)
      const newRects = {};
      Array.from(tableBody.children).forEach(tr => {
        const key = tr.dataset.key;
        newRects[key] = tr.getBoundingClientRect();
      });

      Object.entries(newRects).forEach(([k, newRect]) => {
        const el = tableBody.querySelector(`tr[data-key='${CSS.escape(k)}']`);
        const oldRect = oldRects[k];
        if (oldRect){
          const dy = oldRect.top - newRect.top;
          if (dy !== 0){
            el.style.transform = `translateY(${dy}px)`;
            el.classList.add('moving');
            el.getBoundingClientRect(); 
            
            requestAnimationFrame(() => {
              el.style.transition = 'transform 500ms cubic-bezier(.2,.8,.2,1)';
              el.style.transform = '';
              el.addEventListener('transitionend', function onEnd(e){
                if (e.propertyName === 'transform'){
                  el.classList.remove('moving');
                  el.style.transition = '';
                  el.removeEventListener('transitionend', onEnd);
                }
              });
            });
          }
        }
      });

      // cleanup
      setTimeout(()=> {
        Array.from(tableBody.querySelectorAll('tr.updated-cell')).forEach(tr=> tr.classList.remove('updated-cell'));
      }, 1400);
    }

    /* -- Render podium top 3 (modified name/points rendering) -- */
    function renderPodium(top3){
      // Order: 2nd, 1st, 3rd
      const pods = [
        podium.querySelector('.pod.second'),
        podium.querySelector('.pod.first'),
        podium.querySelector('.pod.third')
      ];
      
      // Data mapping: top3[0] -> 1st, top3[1] -> 2nd, top3[2] -> 3rd
      const dataMap = [
        top3[1], // Data for 2nd place pod
        top3[0], // Data for 1st place pod
        top3[2] // Data for 3rd place pod
      ];

      for (let i = 0; i < 3; i++) {
        const pod = pods[i];
        const data = dataMap[i];
        if (!pod) continue;

        const nameEl = pod.querySelector('.name');
        const pointsEl = pod.querySelector('.points');
        
        if (data){
          nameEl.textContent = (data.name || '—').toUpperCase();
          nameEl.classList.remove('muted');
          pointsEl.textContent = (data.points != null ? data.points : 0).toLocaleString('en-US');
        } else {
          nameEl.textContent = '—';
          pointsEl.textContent = '0';
          nameEl.classList.add('muted');
        }
      }
    }

    /* -- Main render function (intact core logic) -- */
    function processAndRender(allRows){
      if (!allRows || allRows.length < 1) return;
      const headers = allRows[0].map(h => h || '');
      const rawRows = allRows.slice(1).filter(r => r.some(cell => cell.trim() !== ""));

      const ptsIdx = detectPointsColumn(headers, rawRows);
      const nameIdx = (() => {
        const normalized = headers.map(h => (h||"").toLowerCase());
        const candidates = ['name','player','team','id'];
        for (let c of candidates){
          const idx = normalized.indexOf(c);
          if (idx !== -1) return idx;
        }
        return Math.min(1, headers.length-1);
      })();

      const rowObjs = rawRows.map(row => {
        const ptsRaw = (row[ptsIdx] || '').toString().replace(/[^0-9.\-]/g,'').trim();
        const points = ptsRaw === '' || isNaN(Number(ptsRaw)) ? 0 : Number(ptsRaw);
        const name = (row[nameIdx] || '').toString();
        const key = playerKeyFromRow(headers, row);
        return { key, name, points, rowData: row };
      });

      // Sort descending by points
      rowObjs.sort((a,b) => {
        if (b.points !== a.points) return b.points - a.points;
        return a.name.localeCompare(b.name);
      });

      // Assign ranks
      let rank = 0;
      let lastPoints = null;
      rowObjs.forEach((r, idx) => {
        if (lastPoints === null || r.points !== lastPoints){
          rank = idx + 1;
          lastPoints = r.points;
        }
        r.rank = rank;
      });

      buildHeader(headers);
      const newOrderedRows = rowObjs.map(r => ({ key: r.key, rowData: r.rowData, rank: r.rank }));
      
      // Pass required indices for correct cell rendering
      animateReorderAndRender(newOrderedRows, ptsIdx, nameIdx); 
      renderPodium(rowObjs.slice(0,3).map(r => ({ name: r.name, points: r.points })));

      // Update previous state for next diff
      previousRowsMap.clear();
      rowObjs.forEach(r => previousRowsMap.set(r.key, r.rowData.slice()));
      previousOrder = rowObjs.map(r => r.key);
    }

    /* -- top-level update function (intact) -- */
    async function updateLeaderboard(){
      try {
        const csv = await fetchSheetCSV();
        if (!csv || csv.length <= 1){
          tableHead.innerHTML = "<tr><th>No data found</th></tr>";
          tableBody.innerHTML = "";
          renderPodium([]);
          return;
        }
        processAndRender(csv);
      } catch (err){
        console.error("🛑 Failed to update leaderboard:", err);
      }
    }

    // initial load
    updateLeaderboard();

    // poller
    setInterval(updateLeaderboard, POLL_MS);
  </script>
</body>
</html>
