<!DOCTYPE html>
<html lang="en">
<head>
Â  <meta charset="utf-8" />
Â  <meta name="viewport" content="width=device-width,initial-scale=1" />
Â  <title>EIF Leaderboard</title>
Â  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700;800&display=swap" rel="stylesheet">
Â  <style>
Â  Â  /* Page - VIBRANT GRADIENT & MOBILE FOCUS */
Â  Â  :root{
Â  Â  Â  /* Primary Colors */
Â  Â  Â  --bg1: #ff8a00; /* Orange */
Â  Â  Â  --bg2: #ffd24d; /* Yellow */
Â  Â  Â  --bg-page: #f9f9f9; /* Near-white background outside the card */
Â  Â  Â  
Â  Â  Â  /* Card & Text */
Â  Â  Â  --card-bg: #ffffff;
Â  Â  Â  --text-dark: #333333;
Â  Â  Â  --rank-color: #ff5722; /* Deep Orange for Rank */
Â  Â  Â  --update-glow: rgba(0,255,0,0.4);
Â  Â  }
Â  Â  html,body{height:100%;margin:0;}
Â  Â  body{
Â  Â  Â  min-height:100%;
Â  Â  Â  display:flex;
Â  Â  Â  flex-direction:column;
Â  Â  Â  align-items:center;
Â  Â  Â  gap:0; 
Â  Â  Â  font-family: "Poppins", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
Â  Â  Â  color:var(--text-dark);
Â  Â  Â  background: var(--bg-page);
Â  Â  Â  padding:0;
Â  Â  Â  width: 100%;
Â  Â  }
Â  Â  
Â  Â  /* === MAIN CONTAINER (The full orange/yellow background) === */
Â  Â  .main-container {
Â  Â  Â  width: 100%;
Â  Â  Â  max-width: 480px; /* Constrain max width for mobile feel */
Â  Â  Â  min-height: 100vh;
Â  Â  Â  background: linear-gradient(180deg, var(--bg2) 0%, var(--bg1) 100%);
Â  Â  Â  box-shadow: 0 0 30px rgba(0,0,0,0.1);
Â  Â  Â  padding-bottom: 30px;
Â  Â  Â  position: relative;
Â  Â  }

Â  Â  h1{
Â  Â  Â  margin: 0;
Â  Â  Â  padding: 40px 20px 0;
Â  Â  Â  font-size:2rem;
Â  Â  Â  letter-spacing:2px;
Â  Â  Â  text-transform:uppercase;
Â  Â  Â  text-align: center;
Â  Â  Â  color: #fff;
Â  Â  Â  font-weight: 800;
Â  Â  Â  text-shadow: 0 2px 4px rgba(0,0,0,0.1);
Â  Â  }

Â  Â  /* === PODIUM SECTION (Top 3) === */
Â  Â  .podium-wrap{
Â  Â  Â  padding: 30px 20px 20px;
Â  Â  Â  display:flex;
Â  Â  Â  justify-content:center;
Â  Â  Â  align-items:flex-end;
Â  Â  Â  width: 100%;
Â  Â  Â  max-width: 480px;
Â  Â  Â  gap:10px;
Â  Â  }
Â  Â  .pod{
Â  Â  Â  width: 32%; /* Distribute width */
Â  Â  Â  display:flex;
Â  Â  Â  flex-direction:column;
Â  Â  Â  align-items:center;
Â  Â  Â  color: #fff;
Â  Â  Â  text-shadow: 0 1px 2px rgba(0,0,0,0.2);
Â  Â  Â  position:relative;
Â  Â  Â  transition: transform 300ms ease;
Â  Â  }
Â  Â  .pod .icon{
Â  Â  Â  font-size: 3rem;
Â  Â  Â  margin-bottom: 5px;
Â  Â  Â  filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
Â  Â  }
Â  Â  .pod.first .icon { color: #fff; font-size: 4rem; margin-bottom: 0; }
Â  Â  .pod.second .icon { color: #c0c0c0; }
Â  Â  .pod.third .icon { color: #cd7f32; }
Â  Â  
Â  Â  .pod .name{
Â  Â  Â  font-weight:600;
Â  Â  Â  font-size:0.9rem;
Â  Â  Â  white-space:nowrap;
Â  Â  Â  overflow:hidden;
Â  Â  Â  text-overflow:ellipsis;
Â  Â  Â  width: 90%;
Â  Â  Â  text-align:center;
Â  Â  }
Â  Â  .pod .points{
Â  Â  Â  font-size:0.8rem;
Â  Â  Â  font-weight:400;
Â  Â  }
Â  Â  .pod .place { display: none; } /* Hide text rank number */
Â  Â  
Â  Â  /* === LEADERBOARD LIST (The Cards) === */
Â  Â  .table-wrap{
Â  Â  Â  width: 100%;
Â  Â  Â  padding: 0 20px;
Â  Â  Â  box-sizing: border-box;
Â  Â  }
Â  Â  #leaderboard{
Â  Â  Â  display: block; 
Â  Â  Â  width: 100%;
Â  Â  }
Â  Â  #leaderboard thead { display: none; } /* Hide all table headers */
Â  Â  
Â  Â  #leaderboard tbody {
Â  Â  Â  display: flex;
Â  Â  Â  flex-direction: column;
Â  Â  Â  gap: 12px;
Â  Â  Â  padding: 0;
Â  Â  Â  margin: 0;
Â  Â  }
Â  Â  
Â  Â  tbody tr{
Â  Â  Â  display: flex;
Â  Â  Â  width: 100%;
Â  Â  Â  background: var(--card-bg);
Â  Â  Â  border-radius: 40px 10px 10px 40px; /* Shaped card borders */
Â  Â  Â  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
Â  Â  Â  height: 65px;
Â  Â  Â  align-items: center;
Â  Â  Â  transition: transform 500ms ease, box-shadow 500ms ease;
Â  Â  Â  border-left: 5px solid transparent;
Â  Â  }
Â  Â  
Â  Â  /* FLIP move highlight */
Â  Â  .moving {
Â  Â  Â  box-shadow: 0 8px 20px rgba(0,0,0,0.3);
Â  Â  Â  border-color: var(--rank-color);
Â  Â  Â  z-index: 10;
Â  Â  Â  position: relative;
Â  Â  }

Â  Â  /* Cells inside the row are the card components */
Â  Â  tbody td {
Â  Â  Â  display: flex;
Â  Â  Â  padding: 0;
Â  Â  Â  margin: 0;
Â  Â  Â  height: 100%;
Â  Â  Â  align-items: center;
Â  Â  Â  justify-content: center;
Â  Â  Â  border: none; /* Remove table cell borders */
Â  Â  Â  background: none;
Â  Â  Â  min-width: 0;
Â  Â  }

Â  Â  /* Rank (First TD) */
Â  Â  tbody td:nth-child(1) {
Â  Â  Â  background: var(--rank-color);
Â  Â  Â  color: #fff;
Â  Â  Â  width: 35px;
Â  Â  Â  border-radius: 40px 0 0 40px;
Â  Â  Â  font-size: 1.1rem;
Â  Â  Â  font-weight: 800;
Â  Â  Â  flex-shrink: 0;
Â  Â  }
Â  Â  
Â  Â  /* Avatar (Second TD - Placeholder for the Name column from the sheet) */
Â  Â  tbody td:nth-child(2) {
Â  Â  Â  width: 45px;
Â  Â  Â  flex-shrink: 0;
Â  Â  Â  margin-left: 10px;
Â  Â  }
Â  Â  .avatar-placeholder {
Â  Â  Â  width: 45px;
Â  Â  Â  height: 45px;
Â  Â  Â  background: #ccc; 
Â  Â  Â  border-radius: 50%;
Â  Â  Â  overflow: hidden;
Â  Â  Â  border: 2px solid var(--bg1);
Â  Â  }
Â  Â  .avatar-placeholder::after {
Â  Â  Â  content: 'ğŸ‘¤'; 
Â  Â  Â  font-size: 1.8rem;
Â  Â  Â  line-height: 45px;
Â  Â  Â  color: #fff;
Â  Â  }

Â  Â  /* Player Name (Third TD) */
Â  Â  tbody td:nth-child(3) {
Â  Â  Â  justify-content: flex-start;
Â  Â  Â  padding-left: 15px;
Â  Â  Â  font-weight: 700;
Â  Â  Â  flex-grow: 1;
Â  Â  Â  white-space: nowrap;
Â  Â  Â  overflow: hidden;
Â  Â  Â  text-overflow: ellipsis;
Â  Â  }

Â  Â  /* Points/Data Columns (Remaining TDs) */
Â  Â  tbody td:last-child {
Â  Â  Â  font-weight: 800;
Â  Â  Â  color: var(--text-dark);
Â  Â  Â  padding-right: 20px;
Â  Â  Â  flex-shrink: 0;
Â  Â  Â  border-radius: 0 10px 10px 0;
Â  Â  Â  background: var(--bg2); 
Â  Â  Â  height: 100%;
Â  Â  Â  width: 80px;
Â  Â  }
Â  Â  
Â  Â  /* Animation glow for updated cells */
Â  Â  @keyframes cell-glow {
Â  Â  Â  0% { box-shadow: 0 0 10px 2px var(--update-glow); }
Â  Â  Â  100% { box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
Â  Â  }
Â  Â  tbody tr.updated-cell {
Â  Â  Â  animation: cell-glow 1.2s ease forwards;
Â  Â  }
Â  </style>
</head>
<body>
Â  <div class="main-container">
Â  Â  Â  Â  <h1>EIF Leaderboard</h1>

Â  Â  Â  Â  <div class="podium-wrap">
Â  Â  Â  <div class="podium" id="podium">
Â  Â  Â  Â  Â  Â  Â  Â  <div class="pod second" data-place="2">
Â  Â  Â  Â  Â  <div class="icon">ğŸ¥ˆ</div>
Â  Â  Â  Â  Â  <div class="name muted">â€”</div>
Â  Â  Â  Â  Â  <div class="points">0</div>
Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  <div class="pod first" data-place="1">
Â  Â  Â  Â  Â  <div class="icon">ğŸ†</div>
Â  Â  Â  Â  Â  <div class="name muted">â€”</div>
Â  Â  Â  Â  Â  <div class="points">0</div>
Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  <div class="pod third" data-place="3">
Â  Â  Â  Â  Â  <div class="icon">ğŸ¥‰</div>
Â  Â  Â  Â  Â  <div class="name muted">â€”</div>
Â  Â  Â  Â  Â  <div class="points">0</div>
Â  Â  Â  Â  </div>
Â  Â  Â  </div>
Â  Â  </div>

Â  Â  Â  Â  <div class="table-wrap">
Â  Â  Â  <table id="leaderboard" aria-label="Leaderboard">
Â  Â  Â  Â  <thead></thead>
Â  Â  Â  Â  <tbody></tbody>
Â  Â  Â  </table>
Â  Â  </div>
Â  </div>

Â  <script>
Â  Â  /* Â  Â  Â  Â === CONFIG ===
Â  Â  Â  Â The working public CSV URL.
Â  Â  */
Â  Â  const SHEET_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vTQi-z2SLLIg21-uohF1NG58lzZZuPZ6V_wGuQ_g-PTmjvRHcUR3e6PPg4K80i7_Qia_YZkDIJS2eCL/pub?gid=0&single=true&output=csv";

Â  Â  const tableHead = document.querySelector("#leaderboard thead");
Â  Â  const tableBody = document.querySelector("#leaderboard tbody");
Â  Â  const podium = document.getElementById("podium");

Â  Â  // store previous state for change detection and FLIP
Â  Â  let previousRowsMap = new Map();
Â  Â  let previousOrder = [];

Â  Â  const POLL_MS = 15000; // 15 seconds for updates

Â  Â  /* -- utility: robust CSV parser (intact) -- */
Â  Â  function parseCSV(text){
Â  Â  Â  const rows = [];
Â  Â  Â  let cur = "";
Â  Â  Â  let row = [];
Â  Â  Â  let inQuotes = false;
Â  Â  Â  for (let i = 0; i < text.length; i++){
Â  Â  Â  Â  const ch = text[i];
Â  Â  Â  Â  const next = text[i+1];
Â  Â  Â  Â  if (ch === '"' ){
Â  Â  Â  Â  Â  if (inQuotes && next === '"'){
Â  Â  Â  Â  Â  Â  cur += '"'; 
Â  Â  Â  Â  Â  Â  i++;
Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  inQuotes = !inQuotes;
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  } else if (ch === ',' && !inQuotes){
Â  Â  Â  Â  Â  row.push(cur);
Â  Â  Â  Â  Â  cur = "";
Â  Â  Â  Â  } else if ((ch === '\n' || (ch === '\r' && text[i+1] === '\n')) && !inQuotes){
Â  Â  Â  Â  Â  if (ch === '\r' && text[i+1] === '\n') { i++; }
Â  Â  Â  Â  Â  row.push(cur);
Â  Â  Â  Â  Â  rows.push(row.map(c => c.trim()));
Â  Â  Â  Â  Â  row = [];
Â  Â  Â  Â  Â  cur = "";
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  cur += ch;
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  Â  if (cur !== "" || row.length > 0){
Â  Â  Â  Â  row.push(cur);
Â  Â  Â  Â  rows.push(row.map(c => c.trim()));
Â  Â  Â  }
Â  Â  Â  return rows.filter(r => r.length > 0 && r.some(cell => cell !== ""));
Â  Â  }

Â  Â  /* -- auto-detect points column index (intact) -- */
Â  Â  function detectPointsColumn(headers, rows){
Â  Â  Â  const normalized = headers.map(h => (h||"").toString().toLowerCase());
Â  Â  Â  const candidates = ['total','points','score','pts'];
Â  Â  Â  for (let c of candidates){
Â  Â  Â  Â  const idx = normalized.indexOf(c);
Â  Â  Â  Â  if (idx !== -1) return idx;
Â  Â  Â  }
Â  Â  Â  if (rows.length > 0){
Â  Â  Â  Â  const firstRow = rows[0];
Â  Â  Â  Â  for (let i = firstRow.length - 1; i >= 0; i--){
Â  Â  Â  Â  Â  const v = firstRow[i].replace(/[^0-9.\-]/g,"");
Â  Â  Â  Â  Â  if (v !== "" && !isNaN(Number(v))) return i;
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  Â  return headers.length - 1;
Â  Â  }

Â  Â  /* -- CSV fetch with cache busting (intact) -- */
Â  Â  async function fetchSheetCSV(){
Â  Â  Â  const url = SHEET_URL + (SHEET_URL.includes('?') ? '&' : '?') + '_=' + Date.now();
Â  Â  Â  const resp = await fetch(url, {cache: "no-store"});
Â  Â  Â  if (!resp.ok) throw new Error("Failed to fetch sheet: " + resp.status);
Â  Â  Â  const text = await resp.text();
Â  Â  Â  return parseCSV(text);
Â  Â  }

Â  Â  /* -- Create table header (minimal for JS structure) -- */
Â  Â  function buildHeader(headers){
Â  Â  Â  const tr = document.createElement('tr');
Â  Â  Â  const rankTh = document.createElement('th');
Â  Â  Â  rankTh.textContent = 'Rank';
Â  Â  Â  tr.appendChild(rankTh);
Â  Â  Â  headers.forEach(h => {
Â  Â  Â  Â  const th = document.createElement('th');
Â  Â  Â  Â  th.textContent = h || '-';
Â  Â  Â  Â  tr.appendChild(th);
Â  Â  Â  });
Â  Â  Â  tableHead.innerHTML = "";
Â  Â  Â  tableHead.appendChild(tr);
Â  Â  }

Â  Â  /* -- Utility to get unique player id (intact) -- */
Â  Â  function playerKeyFromRow(headers, row){
Â  Â  Â  const normalized = headers.map(h => (h||"").toString().toLowerCase());
Â  Â  Â  const nameIdxCandidates = ['id','player','name','team'];
Â  Â  Â  for (let c of nameIdxCandidates){
Â  Â  Â  Â  const idx = normalized.indexOf(c);
Â  Â  Â  Â  if (idx !== -1 && row[idx]) return row[idx];
Â  Â  Â  }
Â  Â  Â  if (row.length >= 2 && row[1]) return row[1];
Â  Â  Â  return JSON.stringify(row);
Â  Â  }

Â  Â  /* -- FLIP animation and rendering (FIXED for card structure) -- */
Â  Â  function animateReorderAndRender(newOrderedRows, ptsIdx, nameIdx){
Â  Â  Â  const oldElements = {};
Â  Â  Â  Array.from(tableBody.children).forEach(tr => {
Â  Â  Â  Â  const key = tr.dataset.key;
Â  Â  Â  Â  if (key) oldElements[key] = tr;
Â  Â  Â  });

Â  Â  Â  const oldRects = {};
Â  Â  Â  Object.entries(oldElements).forEach(([k, el]) => {
Â  Â  Â  Â  oldRects[k] = el.getBoundingClientRect();
Â  Â  Â  });

Â  Â  Â  const frag = document.createDocumentFragment();
Â  Â  Â  newOrderedRows.forEach(item => {
Â  Â  Â  Â  const {key, rowData} = item;
Â  Â  Â  Â  let tr = oldElements[key];
Â  Â  Â  Â  
Â  Â  Â  Â  if (!tr){
Â  Â  Â  Â  Â  tr = document.createElement('tr');
Â  Â  Â  Â  Â  tr.dataset.key = key;
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  tr.classList.remove('updated-cell');
Â  Â  Â  Â  }
Â  Â  Â  Â  
Â  Â  Â  Â  tr.innerHTML = "";

Â  Â  Â  Â  // Extract data needed for card: Name and Points
Â  Â  Â  Â  const name = rowData[nameIdx] || 'â€”';
Â  Â  Â  Â  const pointsRaw = (rowData[ptsIdx]||'0').replace(/[^0-9.\-]/g,'');
Â  Â  Â  Â  const points = Number(pointsRaw).toLocaleString('en-US');
Â  Â  Â  Â  
Â  Â  Â  Â  // --- START: Build Card TDs (4 total) ---

Â  Â  Â  Â  // 1. Rank cell (TD 1)
Â  Â  Â  Â  const rankTd = document.createElement('td');
Â  Â  Â  Â  rankTd.textContent = item.rank;
Â  Â  Â  Â  tr.appendChild(rankTd);

Â  Â  Â  Â  // 2. Avatar Cell (TD 2)
Â  Â  Â  Â  const avatarTd = document.createElement('td');
Â  Â  Â  Â  avatarTd.innerHTML = '<div class="avatar-placeholder"></div>';
Â  Â  Â  Â  tr.appendChild(avatarTd);

Â  Â  Â  Â  // 3. Name Cell (TD 3)
Â  Â  Â  Â  const nameTd = document.createElement('td');
Â  Â  Â  Â  nameTd.textContent = name;
Â  Â  Â  Â  tr.appendChild(nameTd);

Â  Â  Â  Â  // 4. Points Cell (TD 4)
Â  Â  Â  Â  const pointsTd = document.createElement('td');
Â  Â  Â  Â  pointsTd.textContent = points;
Â  Â  Â  Â  tr.appendChild(pointsTd);
Â  Â  Â  Â  
Â  Â  Â  Â  // --- END: Build Card TDs ---

Â  Â  Â  Â  // Check for changes to trigger the glow animation
Â  Â  Â  Â  const prevRow = previousRowsMap.get(key) || [];
Â  Â  Â  Â  let changed = false;
Â  Â  Â  Â  if (prevRow.length){
Â  Â  Â  Â  Â  const prevPts = Number((prevRow[ptsIdx]||'0').replace(/[^0-9.\-]/g,''));
Â  Â  Â  Â  Â  if (Number(pointsRaw) !== prevPts || prevRow[nameIdx] !== name){
Â  Â  Â  Â  Â  Â  changed = true;
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  const prevRank = previousOrder.indexOf(key) + 1;
Â  Â  Â  Â  Â  if (prevRank !== item.rank && item.rank > 0 && prevRank > 0){
Â  Â  Â  Â  Â  Â  changed = true;
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  if (changed) tr.classList.add('updated-cell');
Â  Â  Â  Â  }

Â  Â  Â  Â  frag.appendChild(tr);
Â  Â  Â  });

Â  Â  Â  tableBody.innerHTML = "";
Â  Â  Â  tableBody.appendChild(frag);

Â  Â  Â  // Measure new rects and apply FLIP transforms (intact)
Â  Â  Â  const newRects = {};
Â  Â  Â  Array.from(tableBody.children).forEach(tr => {
Â  Â  Â  Â  const key = tr.dataset.key;
Â  Â  Â  Â  newRects[key] = tr.getBoundingClientRect();
Â  Â  Â  });

Â  Â  Â  Object.entries(newRects).forEach(([k, newRect]) => {
Â  Â  Â  Â  const el = tableBody.querySelector(`tr[data-key='${CSS.escape(k)}']`);
Â  Â  Â  Â  const oldRect = oldRects[k];
Â  Â  Â  Â  if (oldRect){
Â  Â  Â  Â  Â  const dy = oldRect.top - newRect.top;
Â  Â  Â  Â  Â  if (dy !== 0){
Â  Â  Â  Â  Â  Â  el.style.transform = `translateY(${dy}px)`;
Â  Â  Â  Â  Â  Â  el.classList.add('moving');
Â  Â  Â  Â  Â  Â  el.getBoundingClientRect(); 
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  requestAnimationFrame(() => {
Â  Â  Â  Â  Â  Â  Â  el.style.transition = 'transform 500ms cubic-bezier(.2,.8,.2,1)';
Â  Â  Â  Â  Â  Â  Â  el.style.transform = '';
Â  Â  Â  Â  Â  Â  Â  el.addEventListener('transitionend', function onEnd(e){
Â  Â  Â  Â  Â  Â  Â  Â  if (e.propertyName === 'transform'){
Â  Â  Â  Â  Â  Â  Â  Â  Â  el.classList.remove('moving');
Â  Â  Â  Â  Â  Â  Â  Â  Â  el.style.transition = '';
Â  Â  Â  Â  Â  Â  Â  Â  Â  el.removeEventListener('transitionend', onEnd);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  });

Â  Â  Â  // cleanup
Â  Â  Â  setTimeout(()=> {
Â  Â  Â  Â  Array.from(tableBody.querySelectorAll('tr.updated-cell')).forEach(tr=> tr.classList.remove('updated-cell'));
Â  Â  Â  }, 1400);
Â  Â  }

Â  Â  /* -- Render podium top 3 (modified name/points rendering) -- */
Â  Â  function renderPodium(top3){
Â  Â  Â  // Order: 2nd, 1st, 3rd
Â  Â  Â  const pods = [
Â  Â  Â  Â  podium.querySelector('.pod.second'),
Â  Â  Â  Â  podium.querySelector('.pod.first'),
Â  Â  Â  Â  podium.querySelector('.pod.third')
Â  Â  Â  ];
Â  Â  Â  
Â  Â  Â  // Data mapping: top3[0] -> 1st, top3[1] -> 2nd, top3[2] -> 3rd
Â  Â  Â  const dataMap = [
Â  Â  Â  Â  top3[1], // Data for 2nd place pod
Â  Â  Â  Â  top3[0], // Data for 1st place pod
Â  Â  Â  Â  top3[2] // Data for 3rd place pod
Â  Â  Â  ];

Â  Â  Â  for (let i = 0; i < 3; i++) {
Â  Â  Â  Â  const pod = pods[i];
Â  Â  Â  Â  const data = dataMap[i];
Â  Â  Â  Â  if (!pod) continue;

Â  Â  Â  Â  const nameEl = pod.querySelector('.name');
Â  Â  Â  Â  const pointsEl = pod.querySelector('.points');
Â  Â  Â  Â  
Â  Â  Â  Â  if (data){
Â  Â  Â  Â  Â  nameEl.textContent = (data.name || 'â€”').toUpperCase();
Â  Â  Â  Â  Â  nameEl.classList.remove('muted');
Â  Â  Â  Â  Â  pointsEl.textContent = (data.points != null ? data.points : 0).toLocaleString('en-US');
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  nameEl.textContent = 'â€”';
Â  Â  Â  Â  Â  pointsEl.textContent = '0';
Â  Â  Â  Â  Â  nameEl.classList.add('muted');
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  }

Â  Â  /* -- Main render function (intact core logic) -- */
Â  Â  function processAndRender(allRows){
Â  Â  Â  if (!allRows || allRows.length < 1) return;
Â  Â  Â  const headers = allRows[0].map(h => h || '');
Â  Â  Â  const rawRows = allRows.slice(1).filter(r => r.some(cell => cell.trim() !== ""));

Â  Â  Â  const ptsIdx = detectPointsColumn(headers, rawRows);
Â  Â  Â  const nameIdx = (() => {
Â  Â  Â  Â  const normalized = headers.map(h => (h||"").toLowerCase());
Â  Â  Â  Â  const candidates = ['name','player','team','id'];
Â  Â  Â  Â  for (let c of candidates){
Â  Â  Â  Â  Â  const idx = normalized.indexOf(c);
Â  Â  Â  Â  Â  if (idx !== -1) return idx;
Â  Â  Â  Â  }
Â  Â  Â  Â  return Math.min(1, headers.length-1);
Â  Â  Â  })();

Â  Â  Â  const rowObjs = rawRows.map(row => {
Â  Â  Â  Â  const ptsRaw = (row[ptsIdx] || '').toString().replace(/[^0-9.\-]/g,'').trim();
Â  Â  Â  Â  const points = ptsRaw === '' || isNaN(Number(ptsRaw)) ? 0 : Number(ptsRaw);
Â  Â  Â  Â  const name = (row[nameIdx] || '').toString();
Â  Â  Â  Â  const key = playerKeyFromRow(headers, row);
Â  Â  Â  Â  return { key, name, points, rowData: row };
Â  Â  Â  });

Â  Â  Â  // Sort descending by points
Â  Â  Â  rowObjs.sort((a,b) => {
Â  Â  Â  Â  if (b.points !== a.points) return b.points - a.points;
Â  Â  Â  Â  return a.name.localeCompare(b.name);
Â  Â  Â  });

Â  Â  Â  // Assign ranks
Â  Â  Â  let rank = 0;
Â  Â  Â  let lastPoints = null;
Â  Â  Â  rowObjs.forEach((r, idx) => {
Â  Â  Â  Â  if (lastPoints === null || r.points !== lastPoints){
Â  Â  Â  Â  Â  rank = idx + 1;
Â  Â  Â  Â  Â  lastPoints = r.points;
Â  Â  Â  Â  }
Â  Â  Â  Â  r.rank = rank;
Â  Â  Â  });

Â  Â  Â  buildHeader(headers);
Â  Â  Â  const newOrderedRows = rowObjs.map(r => ({ key: r.key, rowData: r.rowData, rank: r.rank }));
Â  Â  Â  
Â  Â  Â  // Pass required indices for correct cell rendering
Â  Â  Â  animateReorderAndRender(newOrderedRows, ptsIdx, nameIdx); 
Â  Â  Â  renderPodium(rowObjs.slice(0,3).map(r => ({ name: r.name, points: r.points })));

Â  Â  Â  // Update previous state for next diff
Â  Â  Â  previousRowsMap.clear();
Â  Â  Â  rowObjs.forEach(r => previousRowsMap.set(r.key, r.rowData.slice()));
Â  Â  Â  previousOrder = rowObjs.map(r => r.key);
Â  Â  }

Â  Â  /* -- top-level update function (intact) -- */
Â  Â  async function updateLeaderboard(){
Â  Â  Â  try {
Â  Â  Â  Â  const csv = await fetchSheetCSV();
Â  Â  Â  Â  if (!csv || csv.length <= 1){
Â  Â  Â  Â  Â  tableHead.innerHTML = "<tr><th>No data found</th></tr>";
Â  Â  Â  Â  Â  tableBody.innerHTML = "";
Â  Â  Â  Â  Â  renderPodium([]);
Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  }
Â  Â  Â  Â  processAndRender(csv);
Â  Â  Â  } catch (err){
Â  Â  Â  Â  console.error("ğŸ›‘ Failed to update leaderboard:", err);
Â  Â  Â  }
Â  Â  }

Â  Â  // initial load
Â  Â  updateLeaderboard();

Â  Â  // poller
Â  Â  setInterval(updateLeaderboard, POLL_MS);
Â  </script>
</body>
</html>
