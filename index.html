<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>EIF Leaderboard</title>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
<style>
Â  :root{
Â  Â  /* Original Gradient Colors */
Â  Â  --bg1: #ff8a00; /* Deep Orange */
Â  Â  --bg2: #ffd24d; /* Golden Yellow */
Â  Â Â 
Â  Â  /* New Aesthetic Enhancements */
Â  Â  --accent: #1e1e1e; /* Darker text for contrast */
Â  Â  --table-shadow: rgba(0,0,0,0.15);
Â  Â  --update-glow: #e6ffec; /* Light green background for flash */
Â  Â  --moving-color: #008000; /* Darker green for moving row text/border */
Â  Â Â 
Â  Â  /* Podium Colors */
Â  Â  --gold: #FFC72C; /* Brighter Gold */
Â  Â  --silver: #A9B3B9; /* Cleaner Silver */
Â  Â  --bronze: #8B4513; /* Earthy Bronze */
Â  Â  --pod-bg: #ffffff; /* Clean White for Podium Cards */
Â  }
Â  html,body{height:100%;margin:0;}
Â  body{
Â  Â  min-height:100%;
Â  Â  display:flex;
Â  Â  flex-direction:column;
Â  Â  align-items:center;
Â  Â  gap:40px; /* INCREASED GAP */
Â  Â  font-family: "Poppins", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
Â  Â  color:white;Â 
Â  Â  padding:30px 20px;
Â  Â  background: linear-gradient(135deg, var(--bg1) 0%, var(--bg2) 60%);
Â  Â  background-attachment: fixed;
Â  }
Â Â 
Â  /* --- REVAMPED HEADING (BIGGER) --- */
Â  h1{
Â  Â  margin:0;
Â  Â  margin-bottom: 25px; /* Added spacing below H1 */
Â  Â  font-size: 4.5rem;Â 
Â  Â  font-weight: 900;Â 
Â  Â  letter-spacing:3px;
Â  Â  text-transform:uppercase;
Â  Â  display:flex;
Â  Â  align-items:center;
Â  Â  gap:12px;
Â  Â  color: #fff;Â 
Â  Â  text-shadow: 0 6px 12px rgba(0,0,0,0.5);Â 
Â  Â  line-height: 1;
Â  }
Â Â 
Â  /* --- REVAMPED PODIUM STYLING --- */
Â  .podium-wrap{
Â  Â  width:95%;
Â  Â  max-width:1000px;
Â  Â  display:flex;
Â  Â  justify-content:center;
Â  Â  align-items:flex-end;
Â  Â  gap:18px;
Â  Â  padding:10px;
Â  Â  margin-bottom: 20px;
Â  }
Â  .podium{
Â  Â  display:flex;
Â  Â  gap:16px;
Â  Â  align-items:flex-end;
Â  Â  width:100%;
Â  Â  justify-content:center;
Â  Â  max-width:900px;
Â  }
Â  .pod{
Â  Â  width: 180px;
Â  Â  min-height: 120px;
Â  Â  border-radius:16px;
Â  Â  background: var(--pod-bg);Â 
Â  Â  color: var(--accent);
Â  Â  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
Â  Â  display:flex;
Â  Â  flex-direction:column;
Â  Â  align-items:center;
Â  Â  justify-content:flex-end;
Â  Â  padding: 24px 16px 16px;Â 
Â  Â  position:relative;
Â  Â  transform-origin: bottom center;
Â  Â  transition: transform 300ms ease;
Â  Â  border: 3px solid transparent;
Â  }

Â  /* Specific Pod Tiers - Define height/scale for visual hierarchy */
Â  .pod.first{ transform: translateY(-16px) scale(1.05); }Â 
Â  .pod.second{ transform: translateY(0) scale(1.0); }Â 
Â  .pod.third{ transform: translateY(8px) scale(0.95); }Â 
Â Â 
Â  /* The Floating Rank Badge */
Â  .pod .place{
Â  Â  position: absolute;
Â  Â  top: -20px;Â 
Â  Â  left: 50%;
Â  Â  transform: translateX(-50%);
Â  Â  font-weight: 900;Â 
Â  Â  font-size: 2.2rem;Â 
Â  Â  line-height: 1.2;
Â  Â  padding: 6px 14px;
Â  Â  border-radius: 10px;
Â  Â  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
Â  Â  border: 3px solid;
Â  Â  z-index: 20;
Â  Â  /* FIX: Center the text and emoji inside the badge */
Â  Â  text-align: center;Â 
Â  }
Â Â 
Â  /* Badge Colors */
Â  .pod.first .place { background: var(--gold); color: #333; border-color: #fff; }
Â  .pod.second .place { background: var(--silver); color: #333; border-color: #fff; }
Â  .pod.third .place { background: var(--bronze); color: white; border-color: #fff; }

Â  /* Ensure Full Name Display */
Â  .pod .name{
Â  Â  font-weight: 800;Â 
Â  Â  font-size: 1.1rem;Â 
Â  Â  white-space: normal;Â 
Â  Â  text-overflow: clip;Â 
Â  Â  overflow: visible;
Â  Â  width:100%;
Â  Â  text-align:center;
Â  Â  color: var(--accent);
Â  Â  margin-top: 8px;
Â  Â  line-height: 1.2;
Â  }
Â Â 
Â  /* Points */
Â  .pod .points{
Â  Â  font-size:1.1rem;Â 
Â  Â  margin-top: 10px;
Â  Â  padding: 0;
Â  Â  background: transparent;
Â  Â  font-weight: 600;Â 
Â  Â  color: #444;Â 
Â  }
Â Â 
Â  /* --- TABLE STYLING --- */
Â  .table-wrap{
Â  Â  width: 95%;
Â  Â  max-width: 1000px;
Â  Â  background: transparent;Â 
Â  Â  border-radius:14px;
Â  Â  padding:0 10px 10px;Â 
Â  Â  box-shadow: 0 15px 40px var(--table-shadow);Â 
Â  Â  overflow-x: auto;
Â  }
Â  table{
Â  Â  width:100%;
Â  Â  border-collapse: separate;Â 
Â  Â  border-spacing: 0 14px;Â 
Â  Â  overflow: hidden;
Â  Â  color:var(--accent);Â 
Â  Â  table-layout: auto;Â 
Â  Â  padding-top: 50px;Â 
Â  }
Â  thead{
Â  Â  position: sticky;
Â  Â  top: 0;
Â  Â  z-index: 10;
Â  Â  background: #fcfcfc;Â 
Â  Â  border-radius: 14px 14px 0 0;
Â  Â  box-shadow: 0 5px 10px rgba(0,0,0,0.1);
Â  }
Â  thead th{
Â  Â  padding:15px 10px;
Â  Â  text-transform:uppercase;
Â  Â  font-size:0.85rem;
Â  Â  letter-spacing:1.5px;
Â  Â  text-align:center;
Â  Â  background: linear-gradient(to bottom, #f5f5f5, #e0e0e0);
Â  Â  border-bottom:3px solid var(--bg1);
Â  Â  color: #444;
Â  }
Â  tbody tr{
Â  Â  border-radius: 8px;Â 
Â  Â  box-shadow: 0 4px 8px rgba(0,0,0,0.1);Â 
Â  Â  background-color: white;Â 
Â  Â  transition: transform 500ms cubic-bezier(.2,.8,.2,1), background-color 220ms ease, box-shadow 500ms ease;
Â  Â  will-change: transform;
Â  Â  position: relative;Â 
Â  Â  font-weight: 500;
Â  }
Â  tbody td{
Â  Â  padding:14px 10px;
Â  Â  text-align:center;
Â  Â  border-bottom: none;Â 
Â  Â  font-size:1rem;
Â  Â  vertical-align:middle;
Â  Â  font-weight: 500;
Â  }
Â  /* Round the corners of the individual rows */
Â  tbody td:first-child { border-top-left-radius: 8px; border-bottom-left-radius: 8px; }
Â  tbody td:last-child { border-top-right-radius: 8px; border-bottom-right-radius: 8px; }

Â  /* Green flash for any change (data or rank) */
Â  tbody tr.updated-cell {
Â  Â  background-color: var(--update-glow) !important;Â 
Â  }

Â  /* Movement and high Z-index for rank changes (sliding row) */
Â  tbody tr.moving {
Â  Â  box-shadow: 0 12px 30px rgba(0, 150, 0, 0.4);
Â  Â  background-color: #8cffb3 !important; /* Bright green while moving */
Â  Â  color: var(--moving-color);
Â  Â  font-weight: 700;Â 
Â  Â  z-index: 5;Â 
Â  Â  border: 1px solid var(--moving-color);
Â  }

Â  @media (max-width:760px){
Â  Â  h1{font-size:2.5rem; letter-spacing:1px; margin-bottom: 10px;}
Â  Â  .pod{ width:100px; min-height:100px; padding: 18px 10px 10px; }
Â  Â  .pod.first, .pod.second, .pod.third { transform: none; }
Â  Â  .pod .place { font-size: 1.5rem; top: -15px; }
Â  Â  .pod .name { font-size: 0.8rem; }
Â  Â  .pod .points { font-size: 0.9rem; }
Â  Â  tbody td { font-size: 0.85rem; padding: 10px 5px;}
Â  Â  thead th { font-size: 0.75rem; padding: 10px 5px;}
Â  }
Â  .muted{opacity:0.9;font-weight:500;font-size:0.9rem;}
</style>
</head>
<body>
<h1>EIF LEADERBOARD</h1>Â 

<div class="podium-wrap">
Â  <div class="podium" id="podium">
Â  Â  Â  Â  <div class="pod second" data-place="2"><div class="place">2nd ðŸ¥ˆ</div><div class="name muted">â€”</div><div class="points">0 pts</div></div>
Â  Â  Â  Â  <div class="pod first" data-place="1"><div class="place">1st ðŸ¥‡</div><div class="name muted">â€”</div><div class="points">0 pts</div></div>
Â  Â  Â  Â  <div class="pod third" data-place="3"><div class="place">3rd ðŸ¥‰</div><div class="name muted">â€”</div><div class="points">0 pts</div></div>
Â  </div>
</div>

<div class="table-wrap">
Â  <table id="leaderboard" aria-label="Leaderboard">
Â  Â  <thead></thead>
Â  Â  <tbody></tbody>
Â  </table>
</div>

<script>
const SHEET_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vTQi-z2SLLIg21-uohF1NG58lzZZuPZ6V_wGuQ_g-PTmjvRHcUR3e6PPg4K80i7_Qia_YZkDIJS2eCL/pub?gid=0&single=true&output=csv";

const tableHead = document.querySelector("#leaderboard thead");
const tableBody = document.querySelector("#leaderboard tbody");
const podium = document.getElementById("podium");
let previousRowsMap = new Map(); // Stores the full row data for content comparison
let previousRanks = new Map();Â  // Stores rank by key for rank change comparison
let previousOrder = [];Â  Â  Â  Â  Â // Stores player keys in rank order

// *** CHANGED: Polling interval set to 10000ms (10s) ***
const POLL_MS = 10000;Â 

/**
Â * Parses CSV text data into an array of arrays (rows and columns).
Â */
function parseCSV(text){
Â  const rows = [];
Â  let cur="", row=[], inQuotes=false;
Â  for (let i=0;i<text.length;i++){
Â  Â  const ch=text[i], next=text[i+1];
Â  Â  if(ch==='"'){
Â  Â  Â  if(inQuotes && next==='"'){ cur+='"'; i++; } else { inQuotes=!inQuotes; }
Â  Â  } else if(ch===',' && !inQuotes){ row.push(cur); cur=""; }
Â  Â  else if((ch==='\n'||(ch==='\r'&&text[i+1]==='\n')) && !inQuotes){
Â  Â  Â  if(ch==='\r'&&text[i+1]==='\n'){ i++; }
Â  Â  Â  row.push(cur); rows.push(row.map(c=>c.trim())); row=[]; cur="";
Â  Â  } else { cur+=ch; }
Â  }
Â  if(cur!==""||row.length>0){ row.push(cur); rows.push(row.map(c=>c.trim())); }
Â  return rows.filter(r=>r.length>0 && r.some(c=>c!==""));
}

/**
Â * Attempts to automatically identify the column containing the scores/points.
Â */
function detectPointsColumn(headers, rows){
Â  const normalized = headers.map(h=>(h||"").toLowerCase().replace(/[^a-z0-9]/g, ''));
Â  const candidates = ['total','points','score','pts'];
Â  // 1. Check for header keywords
Â  for(let c of candidates){
Â  Â  const idx = normalized.indexOf(c);
Â  Â  if(idx!==-1) return idx;
Â  }
Â  // 2. Fallback: Check for the last column that looks like numbers
Â  if(rows.length > 0) {
Â  Â  for (let i = headers.length - 1; i >= 0; i--) {
Â  Â  Â  Â  let numberCount = 0;
Â  Â  Â  Â  rows.forEach(row => {
Â  Â  Â  Â  Â  Â  const v = (row[i] || '').toString().replace(/[^0-9.\-]/g, '').trim();
Â  Â  Â  Â  Â  Â  if (v !== '' && !isNaN(Number(v))) {
Â  Â  Â  Â  Â  Â  Â  Â  numberCount++;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  });
Â  Â  Â  Â  if (numberCount / rows.length > 0.5) { return i; }
Â  Â  }
Â  }
Â  return headers.length > 0 ? headers.length - 1 : 0;
}

/**
Â * Builds the table header row.
Â */
function buildHeader(headers, ptsIdx){
Â  const tr=document.createElement('tr');
Â  const rankTh=document.createElement('th'); rankTh.textContent='Rank'; tr.appendChild(rankTh);
Â Â 
Â  headers.forEach((h, i) => {Â 
Â  Â  const normalizedH = (h||'').toLowerCase().replace(/[^a-z0-9]/g, '');
Â  Â  if (i !== ptsIdx && normalizedH !== 'rank' && normalizedH !== 'no') {
Â  Â  Â  const th=document.createElement('th');Â 
Â  Â  Â  th.textContent=h||'â€”';Â 
Â  Â  Â  tr.appendChild(th);Â 
Â  Â  }
Â  });
Â Â 
Â  const ptsHeader = headers[ptsIdx] || 'Points';
Â  const ptsTh=document.createElement('th');Â 
Â  ptsTh.textContent = ptsHeader;
Â  tr.appendChild(ptsTh);
Â Â 
Â  tableHead.innerHTML="";Â 
Â  tableHead.appendChild(tr);
}

/**
Â * Generates a unique key for a player/row based on its content for tracking changes.
Â */
function playerKeyFromRow(headers, row, nameIdx, ptsIdx){
Â  const normalized = headers.map(h=>(h||"").toLowerCase().replace(/[^a-z0-9]/g, ''));
Â  const candidates = ['id','player','name','team'];
Â Â 
Â  // Try to find a specific key column first
Â  for(let c of candidates){
Â  Â  const idx=normalized.indexOf(c);Â 
Â  Â  if(idx!==-1 && row[idx]) return row[idx];
Â  }
Â Â 
Â  // Fallback to the determined name column
Â  if(nameIdx !== -1 && row[nameIdx] && nameIdx !== ptsIdx) return row[nameIdx];
Â Â 
Â  // Last fallback: Use the very first non-empty cell that isn't the points column
Â  for(let i = 0; i < row.length; i++) {
Â  Â  Â  if (i !== ptsIdx && row[i] && row[i].trim() !== '') {
Â  Â  Â  Â  Â  return row[i];
Â  Â  Â  }
Â  }

Â  return JSON.stringify(row);
}

/**
Â * Fetches the CSV data from the Google Sheet URL.
Â * Added aggressive Cache-Control headers to prevent reverting to old data.
Â */
async function fetchSheetCSV(){
Â  const url=SHEET_URL+(SHEET_URL.includes('?')?'&':'?')+'_='+Date.now();
Â  // Using 'no-store' and explicit headers to aggressively bypass client and server caching.
Â  const resp=await fetch(url,{
Â  Â  cache:"no-store",
Â  Â  headers: {
Â  Â  Â  Â  'Cache-Control': 'no-cache, no-store, must-revalidate'
Â  Â  }
Â  });Â 
Â  if(!resp.ok) throw new Error("Failed to fetch sheet: "+resp.status);
Â  return parseCSV(await resp.text());
}


/**
Â * Compares old and new row positions and animates the reordering or flashes the score change.
Â */
function animateReorderAndRender(newOrderedRows, nameIdx, ptsIdx, originalHeaders){
Â  const oldElements={};
Â  Array.from(tableBody.children).forEach(tr=>{ const key=tr.dataset.key; if(key) oldElements[key]=tr; });
Â  const oldRects={};
Â  Object.entries(oldElements).forEach(([k,el])=>{ oldRects[k]=el.getBoundingClientRect(); });
Â  const frag=document.createDocumentFragment();

Â  // Create the new elements in the final order
Â  newOrderedRows.forEach(item=>{
Â  Â  const {key,rowData}=item;
Â  Â  let tr=oldElements[key];
Â  Â Â 
Â  Â  const prevRowData = previousRowsMap.get(key) || [];
Â  Â  const prevRank = previousRanks.get(key) || 0;
Â  Â  const currentRank = item.rank;
Â  Â Â 
Â  Â  let dataChanged = false;
Â  Â  // Check if any data cell (including points) has changed
Â  Â  if(prevRowData.length === rowData.length){
Â  Â  Â  Â  for(let i=0;i<rowData.length;i++){
Â  Â  Â  Â  Â  Â  const prevVal = prevRowData[i] || "", curVal = rowData[i] || "";
Â  Â  Â  Â  Â  Â  // Check for change in relevant columns (Name and Points are the most important)
Â  Â  Â  Â  Â  Â  if(i === nameIdx || i === ptsIdx) {
Â  Â  Â  Â  Â  Â  Â  Â  if(prevVal !== curVal){Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  dataChanged = true;Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  } else if (prevRowData.length > 0 || rowData.length > 0) {
Â  Â  Â  Â  // Handle case where column count might have changed (less specific check)
Â  Â  Â  Â  dataChanged = true;
Â  Â  }


Â  Â  // 1. Create/Re-use Row Element and clean up previous state
Â  Â  if(!tr){Â 
Â  Â  Â  tr=document.createElement('tr');Â 
Â  Â  Â  tr.dataset.key=key;Â 
Â  Â  Â  // New row enters with a flash
Â  Â  Â  tr.classList.add('updated-cell');
Â  Â  Â  setTimeout(() => tr.classList.remove('updated-cell'), 3000);
Â  Â  } else {Â 
Â  Â  Â  tr.classList.remove('updated-cell', 'moving');Â 
Â  Â  Â  // Clear any pending timeouts to prevent old flashes from activating
Â  Â  Â  if (tr._flashTimeout) clearTimeout(tr._flashTimeout);
Â  Â  }
Â  Â Â 
Â  Â  // 2. Populate row content
Â  Â  tr.innerHTML="";
Â  Â Â 
Â  Â  // A. Add Rank
Â  Â  const rankTd=document.createElement('td');Â 
Â  Â  rankTd.textContent=item.rank;Â 
Â  Â  tr.appendChild(rankTd);
Â  Â Â 
Â  Â  // B. Add Data Columns (excluding points, rank/no columns)
Â  Â  const dataCells = [];
Â  Â  rowData.forEach((cellVal, i) => {
Â  Â  Â  if (i !== ptsIdx) {
Â  Â  Â  Â  const normalizedH = (originalHeaders[i]||'').toLowerCase().replace(/[^a-z0-9]/g, '');
Â  Â  Â  Â  if (normalizedH !== 'rank' && normalizedH !== 'no') {
Â  Â  Â  Â  Â  Â  const td=document.createElement('td');Â 
Â  Â  Â  Â  Â  Â  td.textContent=cellVal;Â 
Â  Â  Â  Â  Â  Â  dataCells.push(td);
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  });
Â  Â  dataCells.forEach(td => tr.appendChild(td));
Â  Â Â 
Â  Â  // C. Add Points (last column)
Â  Â  const ptsTd = document.createElement('td');
Â  Â  ptsTd.textContent = rowData[ptsIdx] || '0';
Â  Â  tr.appendChild(ptsTd);
Â  Â Â 
Â  Â  // D. Apply Score/Data Flash (if data changed but rank did NOT move)
Â  Â  const rankMoved = (prevRank > 0 && currentRank > 0 && prevRank !== currentRank);
Â  Â Â 
Â  Â  if (dataChanged && !rankMoved) {
Â  Â  Â  Â  // SCORE/DATA CHANGE ONLY: Flash for 3 seconds
Â  Â  Â  Â  tr.classList.add('updated-cell');
Â  Â  Â  Â  tr._flashTimeout = setTimeout(() => {
Â  Â  Â  Â  Â  Â  tr.classList.remove('updated-cell');
Â  Â  Â  Â  }, 3000);
Â  Â  }
Â  Â Â 
Â  Â  frag.appendChild(tr);
Â  });
Â Â 
Â  tableBody.innerHTML=""; tableBody.appendChild(frag);
Â Â 
Â  // 3. Calculate Position Changes and Run FLIP Animation
Â  const newRects={};
Â  Array.from(tableBody.children).forEach(tr=>{Â 
Â  Â  const key=tr.dataset.key;Â 
Â  Â  newRects[key]=tr.getBoundingClientRect();Â 
Â  });

Â  Object.entries(newRects).forEach(([k,newRect])=>{
Â  Â  const el=tableBody.querySelector(`tr[data-key='${CSS.escape(k)}']`);
Â  Â  const oldRect=oldRects[k];
Â  Â  const prevRank = previousRanks.get(k) || 0;
Â  Â  const currentRank = parseInt(el.querySelector('td:first-child').textContent) || 0;
Â  Â Â 
Â  Â  if(!el) return;

Â  Â  // Determine if physical position changed
Â  Â  const dy = oldRect ? oldRect.top - newRect.top : 0;
Â  Â Â 
Â  Â  // Animate ONLY if position changed AND the player's rank number is different
Â  Â  const rankMovedAndPositionChanged = (dy !== 0 && prevRank !== currentRank && prevRank > 0 && currentRank > 0);

Â  Â  if(rankMovedAndPositionChanged){
Â  Â  Â  Â  // RANK MOVEMENT: Full FLIP animation
Â  Â  Â  Â  el.classList.add('moving', 'updated-cell');Â 
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Apply initial transform to old position (First)
Â  Â  Â  Â  el.style.transform=`translateY(${dy}px)`;Â 
Â  Â  Â  Â  el.getBoundingClientRect(); // Forces reflow (Last)
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Start animation to new position (Invert)
Â  Â  Â  Â  requestAnimationFrame(()=>{
Â  Â  Â  Â  Â  Â  el.style.transition='transform 500ms cubic-bezier(.2,.8,.2,1)';
Â  Â  Â  Â  Â  Â  el.style.transform='';
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // Clear the separate score flash timeout if it was set
Â  Â  Â  Â  Â  Â  if (el._flashTimeout) clearTimeout(el._flashTimeout);

Â  Â  Â  Â  Â  Â  // Cleanup after animation completes
Â  Â  Â  Â  Â  Â  el.addEventListener('transitionend',function onEnd(e){
Â  Â  Â  Â  Â  Â  Â  Â  if(e.propertyName==='transform'){Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  el.style.transition='';Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  el.removeEventListener('transitionend',onEnd);Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Keep green flash briefly after animation
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  setTimeout(() => el.classList.remove('moving', 'updated-cell'), 500);Â 
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  });
Â  Â  }
Â  Â  // If the element didn't move, we rely on the flash logic (D) applied earlier.
Â  Â  // If it moved, the transitionend listener handles cleanup.
Â  });
}

/**
Â * Renders the top 3 players onto the podium structure.
Â */
function renderPodium(top3){
Â  const rankTexts = ['1st ðŸ¥‡', '2nd ðŸ¥ˆ', '3rd ðŸ¥‰'];
Â  // The HTML is ordered 2nd, 1st, 3rd, so we map the data accordingly
Â  const pods=[podium.querySelector('.pod.second'),podium.querySelector('.pod.first'),podium.querySelector('.pod.third')];
Â  const dataMap=[top3[1],top3[0],top3[2]];Â 
Â  const textMap = [rankTexts[1], rankTexts[0], rankTexts[2]];
Â Â 
Â  for(let i=0;i<3;i++){
Â  Â  const pod=pods[i],data=dataMap[i];Â 
Â  Â  if(!pod) continue;
Â  Â  const placeEl=pod.querySelector('.place');
Â  Â  const nameEl=pod.querySelector('.name'), pointsEl=pod.querySelector('.points');
Â  Â Â 
Â  Â  // Set the rank text and emoji
Â  Â  placeEl.innerHTML = textMap[i] || `${i+1}th`;Â 
Â  Â Â 
Â  Â  if(data){Â 
Â  Â  Â  let displayName = data.name || 'â€”';Â 
Â  Â  Â  nameEl.textContent=displayName;Â 
Â  Â  Â  nameEl.classList.remove('muted');Â 
Â  Â  Â  pointsEl.textContent=(data.points!=null?data.points:'0')+' pts';Â 
Â  Â  }
Â  Â  else{Â 
Â  Â  Â  nameEl.textContent='â€”';Â 
Â  Â  Â  nameEl.classList.add('muted');Â 
Â  Â  Â  pointsEl.textContent='0 pts';Â 
Â  Â  }
Â  }
}

/**
Â * Main function to fetch, process, sort, and render the data.
Â */
function processAndRender(allRows){
Â  if(!allRows||allRows.length<1) return;
Â  const originalHeaders=allRows[0].map(h=>h||'');Â 
Â  const rawRows=allRows.slice(1).filter(r=>r.some(c=>c.trim()!==""));
Â Â 
Â  const ptsIdx=detectPointsColumn(originalHeaders,rawRows);
Â Â 
Â  let nameIdx = -1;
Â  const normalizedHeaders = originalHeaders.map(h => (h || "").toLowerCase().replace(/[^a-z0-9]/g, ''));
Â  const nameCandidates = ['name', 'player', 'team', 'id'];

Â  for (let c of nameCandidates) {
Â  Â  const idx = normalizedHeaders.indexOf(c);
Â  Â  if (idx !== -1) {
Â  Â  Â  nameIdx = idx;
Â  Â  Â  break;
Â  Â  }
Â  }
Â Â 
Â  if (nameIdx === -1 || nameIdx === ptsIdx) {
Â  Â  nameIdx = originalHeaders.findIndex((_, i) => i !== ptsIdx);
Â  Â  if (nameIdx === -1) nameIdx = 0;Â 
Â  }

Â  if (nameIdx === ptsIdx && originalHeaders.length > 1) {
Â  Â  Â  nameIdx = 0;Â 
Â  }
Â Â 
Â  const rowObjs=rawRows.map(row=>{
Â  Â  const ptsRaw=(row[ptsIdx]||'').toString().replace(/[^0-9.\-]/g,'').trim();
Â  Â  const points=ptsRaw===''||isNaN(Number(ptsRaw))?0:Number(ptsRaw);
Â  Â  const name=(row[nameIdx]||'').toString();Â 
Â  Â  const key=playerKeyFromRow(originalHeaders,row, nameIdx, ptsIdx);
Â  Â  return { key, name, points, rowData:row };
Â  });
Â Â 
Â  // MANDATORY SORTING: Descending by Points, Ascending by Name (tiebreaker)
Â  rowObjs.sort((a,b)=>{Â 
Â  Â  if(b.points!==a.points) return b.points-a.points;Â 
Â  Â  return a.name.localeCompare(b.name);Â 
Â  });
Â Â 
Â  // Calculate Ranks (handles ties)
Â  let rank=0, lastPoints=null;
Â  rowObjs.forEach((r,idx)=>{Â 
Â  Â  if(lastPoints===null||r.points!==lastPoints){Â 
Â  Â  Â  rank=idx+1;Â 
Â  Â  Â  lastPoints=r.points;Â 
Â  Â  }Â 
Â  Â  r.rank=rank;Â 
Â  });
Â Â 
Â  buildHeader(originalHeaders, ptsIdx);
Â  const newOrderedRows=rowObjs.map(r=>({ key:r.key,rowData:r.rowData,rank:r.rank }));
Â Â 
Â  // Call the function to handle animations and rendering
Â  animateReorderAndRender(newOrderedRows, nameIdx, ptsIdx, originalHeaders);
Â  renderPodium(rowObjs.slice(0,3).map(r=>({ name:r.name, points:r.points })));
Â Â 
Â  // Save current state for next comparison
Â  previousRowsMap.clear();Â 
Â  previousRanks.clear();
Â  rowObjs.forEach(r=>{
Â  Â  Â  previousRowsMap.set(r.key,r.rowData.slice());
Â  Â  Â  previousRanks.set(r.key, r.rank);
Â  });
Â  // Note: previousOrder is not strictly necessary anymore, but kept for legacy.
}

/**
Â * Initiates the leaderboard update process.
Â */
async function updateLeaderboard(){
Â  try{
Â  Â  const csv=await fetchSheetCSV();
Â  Â  if(!csv||csv.length<=1){ tableHead.innerHTML="<tr><th>No data found or only header row</th></tr>"; tableBody.innerHTML=""; renderPodium([]); return; }
Â  Â  processAndRender(csv);
Â  }catch(err){ console.error("ðŸ›‘ Failed to update leaderboard:",err); }
}

// Initial load and set interval for continuous data checking (polling)
updateLeaderboard();
setInterval(updateLeaderboard,POLL_MS);
</script>
</body>
</html>
