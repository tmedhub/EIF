<!DOCTYPE html>
<html lang="en">
<head>
Â  <meta charset="utf-8" />
Â  <meta name="viewport" content="width=device-width,initial-scale=1" />
Â  <title>EIF Leaderboard</title>
Â  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
Â  <style>
Â  Â  /* Page */
Â  Â  :root{
Â  Â  Â  --bg1: #ff8a00; /* Orange */
Â  Â  Â  --bg2: #ffd24d; /* Yellow */
Â  Â  Â  --glass: rgba(255,255,255,0.08);
Â  Â  Â  --glass-2: rgba(255,255,255,0.12);
Â  Â  Â  --accent: rgba(255,255,255,0.95);
Â  Â  Â  --update-glow: rgba(0,255,0,0.22);
Â  Â  }
Â  Â  html,body{height:100%;margin:0;}
Â  Â  body{
Â  Â  Â  min-height:100%;
Â  Â  Â  display:flex;
Â  Â  Â  flex-direction:column;
Â  Â  Â  align-items:center;
Â  Â  Â  gap:20px;
Â  Â  Â  font-family: "Poppins", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
Â  Â  Â  color:var(--accent);
Â  Â  Â  padding:28px;
Â  Â  Â  /* Gradient Orange Yellow Background (Issue 1 Resolved) */
Â  Â  Â  background: linear-gradient(135deg, var(--bg1) 0%, var(--bg2) 60%);
Â  Â  Â  background-attachment: fixed;
Â  Â  }

Â  Â  h1{
Â  Â  Â  margin:0;
Â  Â  Â  font-size:2rem;
Â  Â  Â  letter-spacing:2px;
Â  Â  Â  text-transform:uppercase;
Â  Â  Â  display:flex;
Â  Â  Â  align-items:center;
Â  Â  Â  gap:12px;
Â  Â  }

Â  Â  /* Podium */
Â  Â  .podium-wrap{
Â  Â  Â  width:90%;
Â  Â  Â  max-width:1000px;
Â  Â  Â  display:flex;
Â  Â  Â  justify-content:center;
Â  Â  Â  align-items:flex-end;
Â  Â  Â  gap:18px;
Â  Â  Â  padding:10px;
Â  Â  }
Â  Â  .podium{
Â  Â  Â  display:flex;
Â  Â  Â  gap:16px;
Â  Â  Â  align-items:flex-end;
Â  Â  Â  width:100%;
Â  Â  Â  justify-content:center;
Â  Â  Â  max-width:900px;
Â  Â  Â  margin-bottom:6px;
Â  Â  }
Â  Â  .pod{
Â  Â  Â  width:180px;
Â  Â  Â  min-height:110px;
Â  Â  Â  border-radius:12px;
Â  Â  Â  background: linear-gradient(180deg, rgba(255,255,255,0.12), rgba(255,255,255,0.04));
Â  Â  Â  box-shadow: 0 8px 30px rgba(0,0,0,0.25);
Â  Â  Â  display:flex;
Â  Â  Â  flex-direction:column;
Â  Â  Â  align-items:center;
Â  Â  Â  justify-content:flex-end;
Â  Â  Â  padding:12px;
Â  Â  Â  position:relative;
Â  Â  Â  transform-origin: bottom center;
Â  Â  Â  transition: transform 300ms ease;
Â  Â  }
Â  Â  .pod .place{
Â  Â  Â  font-weight:700;
Â  Â  Â  font-size:1.2rem;
Â  Â  Â  margin-bottom:6px;
Â  Â  }
Â  Â  .pod .name{
Â  Â  Â  font-weight:600;
Â  Â  Â  font-size:1rem;
Â  Â  Â  white-space:nowrap;
Â  Â  Â  text-overflow:ellipsis;
Â  Â  Â  overflow:hidden;
Â  Â  Â  width:100%;
Â  Â  Â  text-align:center;
Â  Â  }
Â  Â  .pod .points{
Â  Â  Â  font-size:0.95rem;
Â  Â  Â  margin-top:6px;
Â  Â  Â  background: rgba(0,0,0,0.18);
Â  Â  Â  padding:6px 8px;
Â  Â  Â  border-radius:8px;
Â  Â  Â  font-weight:700;
Â  Â  }
Â  Â  /* podium heights (Issue 6 Resolved) */
Â  Â  .pod.first{ height:180px; transform: translateY(-10px) scale(1.04); border: 3px solid rgba(255,255,255,0.14); }
Â  Â  .pod.second{ height:150px; transform: translateY(0) scale(1.00); }
Â  Â  .pod.third{ height:130px; transform: translateY(6px) scale(.98); }

Â  Â  /* Table */
Â  Â  .table-wrap{
Â  Â  Â  width: 90%;
Â  Â  Â  max-width: 1000px;
Â  Â  Â  background: linear-gradient(180deg, rgba(0,0,0,0.12), rgba(0,0,0,0.06));
Â  Â  Â  border-radius:14px;
Â  Â  Â  padding:10px;
Â  Â  Â  box-shadow: 0 10px 30px rgba(0,0,0,0.25);
Â  Â  }

Â  Â  table{
Â  Â  Â  width:100%;
Â  Â  Â  border-collapse: collapse;
Â  Â  Â  overflow: hidden;
Â  Â  Â  color:var(--accent);
Â  Â  Â  table-layout:auto;
Â  Â  }

Â  Â  thead th{
Â  Â  Â  background: rgba(255,255,255,0.06);
Â  Â  Â  padding:12px 10px;
Â  Â  Â  text-transform:uppercase;
Â  Â  Â  font-size:0.85rem;
Â  Â  Â  letter-spacing:1px;
Â  Â  Â  text-align:center;
Â  Â  Â  border-bottom:1px solid rgba(255,255,255,0.06);
Â  Â  }

Â  Â  tbody td{
Â  Â  Â  padding:12px 10px;
Â  Â  Â  text-align:center;
Â  Â  Â  border-bottom:1px dashed rgba(255,255,255,0.04);
Â  Â  Â  font-size:0.95rem;
Â  Â  Â  vertical-align:middle;
Â  Â  }

Â  Â  tbody tr{
Â  Â  Â  transition: transform 500ms ease, background-color 220ms ease;
Â  Â  Â  will-change: transform;
Â  Â  }

Â  Â  tbody tr.updated-cell td.changed {
Â  Â  Â  animation: cell-glow 1.2s ease;
Â  Â  }

Â  Â  @keyframes cell-glow {
Â  Â  Â  0% { background-color: var(--update-glow); }
Â  Â  Â  100% { background-color: transparent; }
Â  Â  }

Â  Â  /* FLIP move highlight when ranks change (Issue 5 Resolved) */
Â  Â  .moving {
Â  Â  Â  box-shadow: 0 8px 24px rgba(0,0,0,0.25);
Â  Â  Â  border-radius:8px;
Â  Â  Â  background: rgba(255,255,255,0.02);
Â  Â  }

Â  Â  /* small devices */
Â  Â  @media (max-width:760px){
Â  Â  Â  .pod{ width:120px; min-height:90px; }
Â  Â  Â  .pod.first{height:140px;}
Â  Â  Â  .pod.second{height:120px;}
Â  Â  Â  .pod.third{height:110px;}
Â  Â  Â  h1{font-size:1.2rem;}
Â  Â  }

Â  Â  /* utility */
Â  Â  .muted{opacity:0.9;font-weight:600;font-size:0.9rem;}
Â  </style>
</head>
<body>
Â  Â  <h1>EIF Leaderboard</h1>Â 

Â  <div class="podium-wrap">
Â  Â  <div class="podium" id="podium">
Â  Â  Â  Â  Â  Â  <div class="pod second" data-place="2"><div class="place">2</div><div class="name muted">â€”</div><div class="points">0 pts</div></div>
Â  Â  Â  <div class="pod first" data-place="1"><div class="place">1</div><div class="name muted">â€”</div><div class="points">0 pts</div></div>
Â  Â  Â  <div class="pod third" data-place="3"><div class="place">3</div><div class="name muted">â€”</div><div class="points">0 pts</div></div>
Â  Â  </div>
Â  </div>

Â  <div class="table-wrap">
Â  Â  <table id="leaderboard" aria-label="Leaderboard">
Â  Â  Â  <thead></thead>
Â  Â  Â  <tbody></tbody>
Â  Â  </table>
Â  </div>

Â  <script>
Â  Â  /*Â  Â  Â  Â  === CONFIG ===
Â  Â  Â  Â This is the **working** public CSV URL you provided.
Â  Â  */
Â  Â  const SHEET_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vTQi-z2SLLIg21-uohF1NG58lzZZuPZ6V_wGuQ_g-PTmjvRHcUR3e6PPg4K80i7_Qia_YZkDIJS2eCL/pub?gid=0&single=true&output=csv";

Â  Â  const tableHead = document.querySelector("#leaderboard thead");
Â  Â  const tableBody = document.querySelector("#leaderboard tbody");
Â  Â  const podium = document.getElementById("podium");

Â  Â  // store previous state for change detection and FLIP
Â  Â  let previousRowsMap = new Map();
Â  Â  let previousOrder = [];

Â  Â  const POLL_MS = 15000; // 15 seconds for updates

Â  Â  /* -- utility: robust CSV parser (handles quoted fields & commas) -- */
Â  Â  function parseCSV(text){
Â  Â  Â  const rows = [];
Â  Â  Â  let cur = "";
Â  Â  Â  let row = [];
Â  Â  Â  let inQuotes = false;
Â  Â  Â  for (let i = 0; i < text.length; i++){
Â  Â  Â  Â  const ch = text[i];
Â  Â  Â  Â  const next = text[i+1];
Â  Â  Â  Â  if (ch === '"' ){
Â  Â  Â  Â  Â  if (inQuotes && next === '"'){
Â  Â  Â  Â  Â  Â  cur += '"'; // escaped quote
Â  Â  Â  Â  Â  Â  i++;
Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  inQuotes = !inQuotes;
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  } else if (ch === ',' && !inQuotes){
Â  Â  Â  Â  Â  row.push(cur);
Â  Â  Â  Â  Â  cur = "";
Â  Â  Â  Â  } else if ((ch === '\n' || (ch === '\r' && text[i+1] === '\n')) && !inQuotes){
Â  Â  Â  Â  Â  // push row
Â  Â  Â  Â  Â  if (ch === '\r' && text[i+1] === '\n') { i++; /* skip extra */ }
Â  Â  Â  Â  Â  row.push(cur);
Â  Â  Â  Â  Â  rows.push(row.map(c => c.trim()));
Â  Â  Â  Â  Â  row = [];
Â  Â  Â  Â  Â  cur = "";
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  cur += ch;
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  Â  if (cur !== "" || row.length > 0){
Â  Â  Â  Â  row.push(cur);
Â  Â  Â  Â  rows.push(row.map(c => c.trim()));
Â  Â  Â  }
Â  Â  Â  return rows.filter(r => r.length > 0 && r.some(cell => cell !== ""));
Â  Â  }

Â  Â  /* -- auto-detect points column index -- */
Â  Â  function detectPointsColumn(headers, rows){
Â  Â  Â  const normalized = headers.map(h => (h||"").toString().toLowerCase());
Â  Â  Â  const candidates = ['total','points','score','pts'];
Â  Â  Â  for (let c of candidates){
Â  Â  Â  Â  const idx = normalized.indexOf(c);
Â  Â  Â  Â  if (idx !== -1) return idx;
Â  Â  Â  }
Â  Â  Â  // fallback: find last numeric column
Â  Â  Â  if (rows.length > 0){
Â  Â  Â  Â  const firstRow = rows[0];
Â  Â  Â  Â  for (let i = firstRow.length - 1; i >= 0; i--){
Â  Â  Â  Â  Â  const v = firstRow[i].replace(/[^0-9.\-]/g,"");
Â  Â  Â  Â  Â  if (v !== "" && !isNaN(Number(v))) return i;
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  Â  return headers.length - 1; // final fallback
Â  Â  }

Â  Â  /* -- CSV fetch with cache busting to ensure fresh values -- */
Â  Â  async function fetchSheetCSV(){
Â  Â  Â  const url = SHEET_URL + (SHEET_URL.includes('?') ? '&' : '?') + '_=' + Date.now();
Â  Â  Â  const resp = await fetch(url, {cache: "no-store"});
Â  Â  Â  if (!resp.ok) throw new Error("Failed to fetch sheet: " + resp.status);
Â  Â  Â  const text = await resp.text();
Â  Â  Â  return parseCSV(text);
Â  Â  }

Â  Â  /* -- Create table header with Rank column first (Issue 4) -- */
Â  Â  function buildHeader(headers){
Â  Â  Â  const tr = document.createElement('tr');
Â  Â  Â  // Rank added
Â  Â  Â  const rankTh = document.createElement('th');
Â  Â  Â  rankTh.textContent = 'Rank';
Â  Â  Â  tr.appendChild(rankTh);
Â  Â  Â  headers.forEach(h => {
Â  Â  Â  Â  const th = document.createElement('th');
Â  Â  Â  Â  th.textContent = h || '-';
Â  Â  Â  Â  tr.appendChild(th);
Â  Â  Â  });
Â  Â  Â  tableHead.innerHTML = "";
Â  Â  Â  tableHead.appendChild(tr);
Â  Â  }

Â  Â  /* -- Utility to get unique player id from row -- */
Â  Â  function playerKeyFromRow(headers, row){
Â  Â  Â  const normalized = headers.map(h => (h||"").toString().toLowerCase());
Â  Â  Â  const nameIdxCandidates = ['id','player','name','team'];
Â  Â  Â  for (let c of nameIdxCandidates){
Â  Â  Â  Â  const idx = normalized.indexOf(c);
Â  Â  Â  Â  if (idx !== -1 && row[idx]) return row[idx];
Â  Â  Â  }
Â  Â  Â  if (row.length >= 2 && row[1]) return row[1];
Â  Â  Â  return JSON.stringify(row);
Â  Â  }

Â  Â  /* -- FLIP animation for reordering rows (Issue 5 Implemented) -- */
Â  Â  function animateReorderAndRender(newOrderedRows, headers){
Â  Â  Â  const oldElements = {};
Â  Â  Â  Array.from(tableBody.children).forEach(tr => {
Â  Â  Â  Â  const key = tr.dataset.key;
Â  Â  Â  Â  if (key) oldElements[key] = tr;
Â  Â  Â  });

Â  Â  Â  const oldRects = {};
Â  Â  Â  Object.entries(oldElements).forEach(([k, el]) => {
Â  Â  Â  Â  oldRects[k] = el.getBoundingClientRect();
Â  Â  Â  });

Â  Â  Â  const frag = document.createDocumentFragment();
Â  Â  Â  newOrderedRows.forEach(item => {
Â  Â  Â  Â  const {key, rowData} = item;
Â  Â  Â  Â  let tr = oldElements[key];
Â  Â  Â  Â Â 
Â  Â  Â  Â  if (!tr){
Â  Â  Â  Â  Â  tr = document.createElement('tr');
Â  Â  Â  Â  Â  tr.dataset.key = key;
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  tr.classList.remove('updated-cell');
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  tr.innerHTML = "";
Â  Â  Â  Â  // Rank cell
Â  Â  Â  Â  const rankTd = document.createElement('td');
Â  Â  Â  Â  rankTd.textContent = item.rank;
Â  Â  Â  Â  tr.appendChild(rankTd);

Â  Â  Â  Â  rowData.forEach(cellVal => {
Â  Â  Â  Â  Â  const td = document.createElement('td');
Â  Â  Â  Â  Â  td.textContent = cellVal;
Â  Â  Â  Â  Â  tr.appendChild(td);
Â  Â  Â  Â  });

Â  Â  Â  Â  // mark changed cells vs previousRowsMap
Â  Â  Â  Â  const prevRow = previousRowsMap.get(key) || [];
Â  Â  Â  Â  let changed = false;
Â  Â  Â  Â  if (prevRow.length){
Â  Â  Â  Â  Â  const tds = tr.querySelectorAll('td');
Â  Â  Â  Â  Â  for (let i=1;i<tds.length;i++){
Â  Â  Â  Â  Â  Â  const prevVal = prevRow[i-1] || "";
Â  Â  Â  Â  Â  Â  const curVal = rowData[i-1] || "";
Â  Â  Â  Â  Â  Â  // Check data cell value change
Â  Â  Â  Â  Â  Â  if (prevVal !== curVal){
Â  Â  Â  Â  Â  Â  Â  tds[i].classList.add('changed');
Â  Â  Â  Â  Â  Â  Â  changed = true;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  // Check if rank changed
Â  Â  Â  Â  Â  const prevRank = previousOrder.indexOf(key) + 1;
Â  Â  Â  Â  Â  if (prevRank !== item.rank && item.rank > 0 && prevRank > 0){
Â  Â  Â  Â  Â  Â  changed = true;
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  if (changed) tr.classList.add('updated-cell');
Â  Â  Â  Â  }

Â  Â  Â  Â  frag.appendChild(tr);
Â  Â  Â  });

Â  Â  Â  tableBody.innerHTML = "";
Â  Â  Â  tableBody.appendChild(frag);

Â  Â  Â  // Measure new rects
Â  Â  Â  const newRects = {};
Â  Â  Â  Array.from(tableBody.children).forEach(tr => {
Â  Â  Â  Â  const key = tr.dataset.key;
Â  Â  Â  Â  newRects[key] = tr.getBoundingClientRect();
Â  Â  Â  });

Â  Â  Â  // Apply FLIP transforms
Â  Â  Â  Object.entries(newRects).forEach(([k, newRect]) => {
Â  Â  Â  Â  const el = tableBody.querySelector(`tr[data-key='${CSS.escape(k)}']`);
Â  Â  Â  Â  const oldRect = oldRects[k];
Â  Â  Â  Â  if (oldRect){
Â  Â  Â  Â  Â  const dy = oldRect.top - newRect.top;
Â  Â  Â  Â  Â  if (dy !== 0){
Â  Â  Â  Â  Â  Â  el.style.transform = `translateY(${dy}px)`;
Â  Â  Â  Â  Â  Â  el.classList.add('moving');
Â  Â  Â  Â  Â  Â  el.getBoundingClientRect(); // force reflow
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  requestAnimationFrame(() => {
Â  Â  Â  Â  Â  Â  Â  el.style.transition = 'transform 500ms cubic-bezier(.2,.8,.2,1)';
Â  Â  Â  Â  Â  Â  Â  el.style.transform = '';
Â  Â  Â  Â  Â  Â  Â  el.addEventListener('transitionend', function onEnd(e){
Â  Â  Â  Â  Â  Â  Â  Â  if (e.propertyName === 'transform'){
Â  Â  Â  Â  Â  Â  Â  Â  Â  el.classList.remove('moving');
Â  Â  Â  Â  Â  Â  Â  Â  Â  el.style.transition = '';
Â  Â  Â  Â  Â  Â  Â  Â  Â  el.removeEventListener('transitionend', onEnd);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  });

Â  Â  Â  // cleanup: remove changed classes after animation
Â  Â  Â  setTimeout(()=> {
Â  Â  Â  Â  Array.from(tableBody.querySelectorAll('tr.updated-cell')).forEach(tr=>{
Â  Â  Â  Â  Â  tr.classList.remove('updated-cell');
Â  Â  Â  Â  Â  tr.querySelectorAll('td.changed').forEach(td=> td.classList.remove('changed'));
Â  Â  Â  Â  });
Â  Â  Â  }, 1400);
Â  Â  }

Â  Â  /* -- Render podium top 3 (Issue 6 Logic is correct) -- */
Â  Â  function renderPodium(top3){
Â  Â  Â  // Order: 2nd, 1st, 3rd to match visual layout
Â  Â  Â  const pods = [
Â  Â  Â  Â  podium.querySelector('.pod.second'),
Â  Â  Â  Â  podium.querySelector('.pod.first'),
Â  Â  Â  Â  podium.querySelector('.pod.third')
Â  Â  Â  ];
Â  Â  Â Â 
Â  Â  Â  // Data mapping: top3[0] -> 1st place, top3[1] -> 2nd place, top3[2] -> 3rd place
Â  Â  Â  const dataMap = [
Â  Â  Â  Â  top3[1], // Data for 2nd place pod
Â  Â  Â  Â  top3[0], // Data for 1st place pod
Â  Â  Â  Â  top3[2] // Data for 3rd place pod
Â  Â  Â  ];

Â  Â  Â  for (let i = 0; i < 3; i++) {
Â  Â  Â  Â  const pod = pods[i];
Â  Â  Â  Â  const data = dataMap[i];
Â  Â  Â  Â  if (!pod) continue;

Â  Â  Â  Â  const nameEl = pod.querySelector('.name');
Â  Â  Â  Â  const pointsEl = pod.querySelector('.points');
Â  Â  Â  Â Â 
Â  Â  Â  Â  if (data){
Â  Â  Â  Â  Â  nameEl.textContent = data.name || 'â€”';
Â  Â  Â  Â  Â  nameEl.classList.remove('muted');
Â  Â  Â  Â  Â  pointsEl.textContent = (data.points != null ? data.points : '0') + ' pts';
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  nameEl.textContent = 'â€”';
Â  Â  Â  Â  Â  pointsEl.textContent = '0 pts';
Â  Â  Â  Â  Â  nameEl.classList.add('muted');
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  }

Â  Â  /* -- Main render function: sorts, sets ranks, updates table & podium (Issue 4 Logic is correct) -- */
Â  Â  function processAndRender(allRows){
Â  Â  Â  if (!allRows || allRows.length < 1) return;
Â  Â  Â  const headers = allRows[0].map(h => h || '');
Â  Â  Â  const rawRows = allRows.slice(1).filter(r => r.some(cell => cell.trim() !== ""));

Â  Â  Â  const ptsIdx = detectPointsColumn(headers, rawRows);
Â  Â  Â  const nameIdx = (() => {
Â  Â  Â  Â  const normalized = headers.map(h => (h||"").toLowerCase());
Â  Â  Â  Â  const candidates = ['name','player','team','id'];
Â  Â  Â  Â  for (let c of candidates){
Â  Â  Â  Â  Â  const idx = normalized.indexOf(c);
Â  Â  Â  Â  Â  if (idx !== -1) return idx;
Â  Â  Â  Â  }
Â  Â  Â  Â  return Math.min(1, headers.length-1);
Â  Â  Â  })();

Â  Â  Â  const rowObjs = rawRows.map(row => {
Â  Â  Â  Â  const ptsRaw = (row[ptsIdx] || '').toString().replace(/[^0-9.\-]/g,'').trim();
Â  Â  Â  Â  const points = ptsRaw === '' || isNaN(Number(ptsRaw)) ? 0 : Number(ptsRaw);
Â  Â  Â  Â  const name = (row[nameIdx] || '').toString();
Â  Â  Â  Â  const key = playerKeyFromRow(headers, row);
Â  Â  Â  Â  return { key, name, points, rowData: row };
Â  Â  Â  });

Â  Â  Â  // Sort descending by points (Issue 4)
Â  Â  Â  rowObjs.sort((a,b) => {
Â  Â  Â  Â  if (b.points !== a.points) return b.points - a.points;
Â  Â  Â  Â  // Tiebreaker: sort by name
Â  Â  Â  Â  return a.name.localeCompare(b.name);
Â  Â  Â  });

Â  Â  Â  // Assign ranks (dense rank)
Â  Â  Â  let rank = 0;
Â  Â  Â  let lastPoints = null;
Â  Â  Â  rowObjs.forEach((r, idx) => {
Â  Â  Â  Â  if (lastPoints === null || r.points !== lastPoints){
Â  Â  Â  Â  Â  rank = idx + 1;
Â  Â  Â  Â  Â  lastPoints = r.points;
Â  Â  Â  Â  }
Â  Â  Â  Â  r.rank = rank;
Â  Â  Â  });

Â  Â  Â  buildHeader(headers);
Â  Â  Â  const newOrderedRows = rowObjs.map(r => ({ key: r.key, rowData: r.rowData, rank: r.rank }));
Â  Â  Â  animateReorderAndRender(newOrderedRows, headers);
Â  Â  Â  renderPodium(rowObjs.slice(0,3).map(r => ({ name: r.name, points: r.points })));

Â  Â  Â  // Update previous state for next diff
Â  Â  Â  previousRowsMap.clear();
Â  Â  Â  rowObjs.forEach(r => previousRowsMap.set(r.key, r.rowData.slice()));
Â  Â  Â  previousOrder = rowObjs.map(r => r.key);
Â  Â  }

Â  Â  /* -- top-level update function -- */
Â  Â  async function updateLeaderboard(){
Â  Â  Â  try {
Â  Â  Â  Â  console.log(`Fetching data from sheet...`);
Â  Â  Â  Â  const csv = await fetchSheetCSV();
Â  Â  Â  Â  console.log(`Data fetched successfully. Rows: ${csv.length}`);
Â  Â  Â  Â  if (!csv || csv.length <= 1){
Â  Â  Â  Â  Â  tableHead.innerHTML = "<tr><th>No data found or only header row</th></tr>";
Â  Â  Â  Â  Â  tableBody.innerHTML = "";
Â  Â  Â  Â  Â  renderPodium([]);
Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  }
Â  Â  Â  Â  processAndRender(csv);
Â  Â  Â  } catch (err){
Â  Â  Â  Â  console.error("ðŸ›‘ Failed to update leaderboard. Check your Google Sheets URL and ensure CORS policy allows fetching:", err);
Â  Â  Â  }
Â  Â  }

Â  Â  // initial load
Â  Â  updateLeaderboard();

Â  Â  // poller
Â  Â  setInterval(updateLeaderboard, POLL_MS);
Â  </script>
</body>
</html>
